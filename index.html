<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Readings (annotator)</title>

<!-- markdown renderer + firebase (compat libs kept) -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

<style>
:root{--bg:#0f0b08;--panel:#17120f;--muted:#c9b89a;--muted-2:#7b6a58;--accent:#b36b2c;--glass:rgba(255,255,255,0.02);--highlight:rgba(179,107,44,0.18);--radius:12px}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--muted);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial}
header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;border-bottom:1px solid rgba(255,255,255,0.02)}
h1{margin:0;font-size:16px}
.app{display:flex;height:calc(100vh - 64px);gap:16px;padding:16px}
.col{background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.01));border-radius:var(--radius);Padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);overflow:auto;position:relative}
.left{width:280px;flex-shrink:0}.center{flex:1;min-width:320px}.right{width:320px;flex-shrink:0}
.col.collapsed{width:44px !important;padding:6px !important;overflow:visible !important}
.col.collapsed .panel-body{display:none}
.col.collapsed .panel-header .title-wrap{display:none}
.col.collapsed .panel-header{justify-content:center}

.panel-mini{display:none;font-size:16px}
.reading-item{padding:14px;border-radius:8px;background:var(--glass);margin-bottom:8px;cursor:pointer;display:flex;align-items:center;justify-content:center}
.reading-title{font-weight:600}
.small{font-size:12px;color:var(--muted-2)}
#article{line-height:1.6;color:var(--muted);padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent);outline:none}
.hl{background:var(--highlight);border-radius:4px;padding:0 2px;cursor:pointer}
.ann-group{margin-bottom:12px;border-radius:8px;padding:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
.ann-tabs{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px}
.ann-tab{padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);cursor:pointer;font-size:13px;color:var(--muted-2)}
.ann-active{background:linear-gradient(90deg,var(--accent), #8a5a2a);color:#fff;border:none}
.annotation-editor{margin-bottom:12px}
textarea{width:100%;min-height:88px;border-radius:8px;padding:8px;background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}
#annot-fab{position:absolute;z-index:9999;display:none;padding:8px 12px;border-radius:999px;background:linear-gradient(90deg,var(--accent), #8a5a2a);color:white;border:none;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,0.5);font-weight:600}
#lookup-btn{position:absolute;z-index:9999;display:none;padding:6px 10px;border-radius:999px;background:linear-gradient(90deg,#fff,#eee);color:#111;border:none;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.35);font-weight:600}
.collapse-btn{background:rgba(255,255,255,0.03);color:var(--muted);border:1px solid rgba(255,255,255,0.02);padding:6px;border-radius:8px;cursor:pointer}
.collapse-icon{width:30px;height:30px;display:inline-flex;align-items:center;justify-content:center;border-radius:6px;font-weight:700;padding:0}
.panel-header { display:flex;justify-content:space-between;align-items:center;margin-bottom:8px }
.panel-header .title-wrap{display:flex;flex-direction:column}
#annotations-list .ann-group .ann-tabs{margin-bottom:6px}
#pw-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.92);z-index:100000}
#pw-box{width:420px;background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.01));padding:26px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 20px 80px rgba(0,0,0,0.8);text-align:center}
#pw-box h3{margin:0 0 8px 0;color:var(--muted);font-size:18px}
#pw-box .pw-note{color:var(--muted-2);font-size:13px;margin-bottom:12px}
#pw-box input{width:100%;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);margin-top:6px}
#pw-submit{width:180px;padding:12px;border-radius:10px;border:none;margin-top:12px;background:linear-gradient(90deg,var(--accent), #8a5a2a);color:white;font-weight:700;cursor:pointer}

.comment-modal{position:fixed;right:18px;bottom:18px;z-index:200000;max-width:520px;background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
.comment-item{padding:6px;border-radius:6px;margin-bottom:6px;background:rgba(0,0,0,0.02);font-size:13px}
.comment-input{display:flex;gap:8px;margin-top:8px}
.comment-input textarea{min-height:56px}

#define-modal{display:none;position:fixed;right:18px;bottom:18px;z-index:200001;background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);max-width:420px;color:var(--muted)}
#define-modal .close-btn{margin-top:8px}

::-webkit-scrollbar{width:10px;height:10px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:linear-gradient(180deg, rgba(179,107,44,0.18), rgba(179,107,44,0.12));border-radius:10px;border:2px solid rgba(0,0,0,0)}
*{scrollbar-width:thin;scrollbar-color: rgba(179,107,44,0.18) transparent}

@media (max-width:980px){.app{flex-direction:column;height:calc(100vh - 88px);padding:10px}#annot-fab{position:fixed;right:14px;bottom:90px}#lookup-btn{position:fixed;right:14px;bottom:150px}}
</style>
</head>
<body>

<header>
  <div style="display:flex;gap:12px;align-items:center"><h1>Readings</h1><div class="small">(and also annotating if you wish to)</div></div>
  <div style="display:flex;gap:8px;align-items:center"></div>
</header>

<div class="app">
  <aside class="col left" id="left-col">
    <div class="panel-header">
      <div class="title-wrap"><div class="small">Primarily just short stories</div><strong style="font-size:15px">Readings</strong></div>
      <button class="collapse-btn collapse-icon" id="collapse-left" title="Toggle left">O</button>
    </div>

    <div class="panel-body">
      <div id="reading-list"><div class="small">Loading…</div></div>
      <hr style="border:none;height:1px;background:rgba(255,255,255,0.02);margin:12px 0" />
      <div id="index-json-path" style="display:none;margin-top:6px;color:var(--muted-2)"></div>
      <div id="debug-block" style="display:none"></div>
    </div>
  </aside>

  <main class="col center">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
      <div><h2 id="post-title" style="margin:4px 0 0 0">Nothing loaded</h2></div>
      <div style="text-align:right"><div id="current-file" class="small" style="display:none">—</div></div>
    </div>
    <div id="article" tabindex="0" aria-label="Article content"><div class="small">Open a reading from the left.</div></div>
  </main>

  <aside class="col right" id="right-col">
    <div class="panel-header">
      <div class="title-wrap"><strong style="font-size:15px">Annotations</strong></div>
      <button class="collapse-btn collapse-icon" id="collapse-right" title="Toggle right">X</button>
    </div>

    <div class="panel-body">
      <div id="annotation-editor" class="annotation-editor" style="display:none">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Add annotation</strong></div>
          <div class="small" id="selection-preview"></div>
        </div>
        <textarea id="annotation-text" placeholder="write your note"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button class="collapse-btn" id="save-annotation">Save</button>
          <button class="collapse-btn" id="cancel-annotation">Cancel</button>
          <button class="collapse-btn" id="delete-annotation" style="display:none;background:rgba(255,64,64,0.06);color:var(--muted)">Delete</button>
        </div>
        <div class="small" style="margin-top:8px;color:var(--muted-2)">This will get saved for anyone else to see. You can edit or delete it later.</div>
      </div>

      <div id="annotations-list"><div class="small">Select text to create an annotation.</div></div>
    </div>
  </aside>
</div>

<button id="annot-fab" aria-label="Annotate">Annotate</button>
<button id="lookup-btn" aria-label="Look up">Look up</button>

<div id="pw-overlay">
  <div id="pw-box">
    <h3>Password</h3>
    <div class="pw-note">I don't know why I added this</div>
    <input id="pw-input" placeholder="Password" autocomplete="off"/>
    <div style="display:flex;justify-content:center">
      <button id="pw-submit">Unlock</button>
    </div>
  </div>
</div>

<!-- comment modal -->
<div id="comment-modal" class="comment-modal" style="display:none">
  <div style="display:flex;justify-content:space-between;align-items:center"><strong>Comments</strong><button class="collapse-btn" id="close-comments">Close</button></div>
  <div id="comments-list" style="margin-top:8px"><div class="small">No comments loaded.</div></div>
  <div class="comment-input">
    <textarea id="comment-text" placeholder="Write a comment..."></textarea>
    <button class="collapse-btn" id="post-comment">Post</button>
  </div>
</div>

<!-- define modal (opaque background, not translucent) -->
<div id="define-modal">
  <div id="define-content"></div>
  <div style="text-align:right"><button class="collapse-btn close-btn" id="close-define">Close</button></div>
</div>

<script>
/*
  Implemented fixes A-F:
  A) Accurate display->raw mapping (displayToRawMap) to avoid index shift
  B) FAB pointerdown prevents selection loss and reliably captures selection
  C) Comments are handled in a persistent modal (not inline) to avoid disappearing after re-render
  D) Lookup UI: "Look up" button next to Annotate for single-word selections; opaque define modal
  E) Fallback string-match only used when mapping fails; normalized
  F) Prevent exact-duplicate annotations for same start/end (open editor instead)
*/

const PASSWORD = "Stacy"; // change this
const READINGS_PATH = "readings";   // change if different
/* Paste your Firebase web config here */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyCxhiw5V3epzzWeFxlMGQ8SH4QjWDjH_1A",
  authDomain: "taruornottorue.firebaseapp.com",
  projectId: "taruornottorue",
  // OPTIONAL: storageBucket, messagingSenderId, appId...
  storageBucket: "taruornottorue.firebasestorage.app",
  messagingSenderId: "458061841918",
  appId: "1:458061841918:web:1cc68c086bcbf81ee3acaf"
};




firebase.initializeApp(FIREBASE_CONFIG);
const db = firebase.firestore();

/* DOM helpers */
const $ = s => document.querySelector(s);
const el = (t,a={},h='') => { const e = document.createElement(t); Object.assign(e,a); if(h) e.innerHTML = h; return e; };
function escapeHtml(s){ return (s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;'); }
function normalizeForMatching(s){
  if(s === undefined || s === null) return '';
  return String(s)
    .replace(/\r\n/g,'\n').replace(/\r/g,'\n')
    .replace(/\u2018|\u2019/g,"'")
    .replace(/\u201C|\u201D/g,'"')
    .replace(/\u00A0/g,' ')
    .replace(/\s+/g,' ');
}

/* app state */
window.current = window.current || { filePath: null, raw: null, title: null };
let readings = [];
let pendingSelection = null;
let unsubscribeRealtime = null;
let pollingFallback = null;
window.current.displayToRawMap = []; // map display index -> raw index
window.current.displayText = '';     // the flattened display text (raw without newline chars)

/* password overlay */
function isUnlocked(){ try{ return sessionStorage.getItem('candle_unlocked') === '1'; }catch(e){return false;} }
function setUnlocked(){ try{ sessionStorage.setItem('candle_unlocked','1'); }catch(e){} }
function showOverlay(){ $('#pw-overlay').style.display='flex'; document.body.style.overflow='hidden'; $('#pw-input').focus(); }
function hideOverlay(){ $('#pw-overlay').style.display='none'; document.body.style.overflow=''; }

if(!isUnlocked()) showOverlay(); else initApp();
$('#pw-submit').addEventListener('click', ()=>{ if($('#pw-input').value === PASSWORD){ setUnlocked(); hideOverlay(); initApp(); } else alert('Wrong password'); });
$('#pw-input').addEventListener('keydown', (e)=>{ if(e.key === 'Enter') $('#pw-submit').click(); });

function normalizePath(p){ if(!p) return p; return p.startsWith('/') ? p.slice(1) : p; }

/* Readings discovery/render */
async function discoverReadings(){
  const indexPath = `/${READINGS_PATH}/index.json`;
  try{
    const r = await fetch(indexPath, {cache:'no-store'});
    if(r.ok){
      const arr = await r.json();
      readings = arr.map(item => {
        if(typeof item === 'string') return { path: item, title: item.split('/').pop() };
        return { path: item.path, title: item.title || item.path.split('/').pop(), download_url: item.download_url };
      });
      renderReadingList();
      return;
    }
  }catch(e){ console.warn('discoverReadings error', e); }
  $('#reading-list').innerHTML = '<div class="small">No readings found. Add /readings/index.json</div>';
}

function renderReadingList(){
  const cont = $('#reading-list'); cont.innerHTML = '';
  readings.forEach(r=>{
    const item = el('div',{className:'reading-item'});
    item.innerHTML = `<div style="text-align:center;width:100%"><div class="reading-title">${escapeHtml(r.title)}</div></div>`;
    item.addEventListener('click', ()=> loadReading(r));
    cont.appendChild(item);
  });
}

/* Build display mapping: create displayText (raw without newline chars) and a map displayIndex->rawIndex */
function buildDisplayMapping(raw){
  const map = [];
  let display = '';
  for(let i=0;i<raw.length;i++){
    const ch = raw[i];
    if(ch === '\n') continue; // we remove newlines from display text because in DOM we use <br> or paragraphs
    map.push(i);
    display += ch;
  }
  return { displayText: display, displayToRawMap: map };
}

/* build annotated HTML (uses raw indices for spans) */
function buildAnnotatedHtml(text, anns){
  // sanitize and ensure numeric start/end
  anns = (anns || []).slice().map(a => {
    const s = Number(a.start_idx ?? a.start);
    const e = Number(a.end_idx ?? a.end);
    return Object.assign({}, a, { start_idx: s, end_idx: e });
  }).filter(a => !isNaN(a.start_idx) && !isNaN(a.end_idx) && a.end_idx > a.start_idx)
    .sort((a,b)=> a.start_idx - b.start_idx);

  // dedupe exact same start/end (keep first)
  const seen = new Set();
  const filtered = [];
  for(const a of anns){
    const key = `${a.start_idx}:${a.end_idx}`;
    if(seen.has(key)) continue;
    seen.add(key);
    filtered.push(a);
  }

  // groups by identical start/end so that multiple notes on same span are grouped
  const groups = [];
  for(const a of filtered){
    const start = a.start_idx;
    const end = a.end_idx;
    const last = groups.length ? groups[groups.length-1] : null;
    if(last && last.start === start && last.end === end) last.items.push(a);
    else groups.push({ start, end, items: [a] });
  }

  // Build output by iterating raw string slices and injecting spans at start/end
  let out = '', cursor = 0;
  for(const g of groups){
    if(g.start > cursor) out += escapeHtml(text.slice(cursor, g.start));
    const excerpt = escapeHtml(text.slice(g.start, g.end));
    const ids = g.items.map(i=>i.id).join(',');
    out += `<span class="hl" tabindex="0" data-ann-ids="${ids}" data-start="${g.start}" data-end="${g.end}">${excerpt}</span>`;
    cursor = g.end;
  }
  if(cursor < text.length) out += escapeHtml(text.slice(cursor));

  // Convert newlines in the resulting escaped text to paragraphs/line breaks like previously
  out = out.replace(/\n{2,}/g, '</p><p>').replace(/\n/g, '<br>');
  return `<p>${out}</p>`;
}

/* render article and compute display->raw mapping for later accurate conversions */
function renderArticleWithAnnotations(){
  const raw = window.current.raw || '';
  // build display mapping first and store it on window.current
  const mapping = buildDisplayMapping(raw);
  window.current.displayText = mapping.displayText;
  window.current.displayToRawMap = mapping.displayToRawMap;

  const anns = loadAnnsLocal(window.current.filePath) || [];
  $('#article').innerHTML = buildAnnotatedHtml(raw, anns);
  renderAnnGroups(anns);
}

/* local storage helpers */
const STORAGE_PREFIX = 'candle_annot_';
function annKeyFor(fp){ return STORAGE_PREFIX + 'anns::' + fp; }
function loadAnnsLocal(fp){ try{ const s = localStorage.getItem(annKeyFor(fp)); return s ? JSON.parse(s) : []; }catch(e){ return []; } }
function saveAnnsLocal(fp, arr){ localStorage.setItem(annKeyFor(fp), JSON.stringify(arr)); }

/* render annotation groups - same idea but note comments open modal */
function renderAnnGroups(anns){
  const cont = $('#annotations-list'); cont.innerHTML = '';
  if(!anns || anns.length===0){ cont.innerHTML = '<div class="small">No annotations yet.</div>'; return; }
  anns = anns.slice().map(a => ({ ...a, start_idx: Number(a.start_idx ?? a.start), end_idx: Number(a.end_idx ?? a.end) }))
        .filter(a => !isNaN(a.start_idx) && !isNaN(a.end_idx) && a.end_idx > a.start_idx)
        .sort((a,b)=> a.start_idx - b.start_idx);

  // group
  const groups = [];
  for(const a of anns){
    const start = a.start_idx;
    const end = a.end_idx;
    const last = groups.length ? groups[groups.length-1] : null;
    if(last && last.start === start && last.end === end) last.items.push(a);
    else groups.push({ start, end, items: [a] });
  }

  groups.forEach(g=>{
    const excerpt = window.current.raw.slice(g.start, g.end);
    const groupEl = el('div',{className:'ann-group'});
    groupEl.appendChild(el('div',{}, `<div class="small" style="margin-bottom:8px"><em>Excerpt:</em> "${escapeHtml(excerpt.slice(0,200))}${excerpt.length>200?'…':''}"</div>`));
    const tabs = el('div',{className:'ann-tabs'});
    g.items.forEach((it, idx)=>{
      const authorLabel = escapeHtml(it.author || 'Stacy');
      const tab = el('button',{className:'ann-tab'}, authorLabel);
      if(idx===0) tab.classList.add('ann-active');
      tab.addEventListener('click', ()=> {
        tabs.querySelectorAll('.ann-tab').forEach(t=>t.classList.remove('ann-active'));
        tab.classList.add('ann-active');
        body.innerHTML = `${marked.parseInline(it.note||'')}<div style="margin-top:8px;display:flex;gap:8px">
          <button class="collapse-btn" data-id="${it.id}" data-action="jump">Jump</button>
          <button class="collapse-btn" data-id="${it.id}" data-action="edit">Edit</button>
          <button class="collapse-btn" data-id="${it._remoteId||''}" data-action="comment">Comment</button>
          <button class="collapse-btn" data-id="${it.id}" data-action="delete">Delete</button>
          </div>`;
      });
      tabs.appendChild(tab);
    });
    groupEl.appendChild(tabs);
    const body = el('div',{}, `${marked.parseInline(g.items[0].note||'')}<div style="margin-top:8px;display:flex;gap:8px">
      <button class="collapse-btn" data-id="${g.items[0].id}" data-action="jump">Jump</button>
      <button class="collapse-btn" data-id="${g.items[0].id}" data-action="edit">Edit</button>
      <button class="collapse-btn" data-id="${g.items[0]._remoteId||''}" data-action="comment">Comment</button>
      <button class="collapse-btn" data-id="${g.items[0].id}" data-action="delete">Delete</button>
      </div>`);
    groupEl.appendChild(body);
    cont.appendChild(groupEl);
  });

  cont.querySelectorAll('[data-action]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-id'), action = btn.getAttribute('data-action');
      const anns = loadAnnsLocal(window.current.filePath) || [];
      const ann = anns.find(a=> String(a.id) === String(id)) || anns.find(a => String(a._remoteId) === String(id));
      if(action === 'jump'){
        if(!ann) return alert('Not found');
        const sp = document.querySelector(`[data-ann-ids*="${ann.id}"]`) || document.querySelector(`[data-start="${ann.start_idx}"]`);
        if(sp){ sp.scrollIntoView({behavior:'smooth', block:'center'}); sp.animate([{boxShadow:'0 0 0 rgba(0,0,0,0)'},{boxShadow:'0 10px 40px rgba(179,107,44,0.22)'}],{duration:900}); }
      } else if(action === 'edit'){
        if(!ann) return alert('Not found');
        pendingSelection = { start_idx: Number(ann.start_idx), end_idx: Number(ann.end_idx), text: window.current.raw.slice(Number(ann.start_idx), Number(ann.end_idx)) };
        $('#selection-preview').innerText = `"${pendingSelection.text.slice(0,90)}${pendingSelection.text.length>90?'…':''}"`;
        $('#annotation-text').value = ann.note || '';
        $('#annotation-editor').style.display = 'block';
        $('#annotation-editor').dataset.editing = ann.id;
        $('#delete-annotation').style.display = 'inline-block';
        $('#delete-annotation').dataset.remoteId = ann._remoteId || '';
        document.getElementById('right-col').classList.remove('collapsed');
      } else if(action === 'comment'){
        const remoteId = id;
        if(!remoteId) return alert('This annotation has not been saved remotely yet. Save first to enable comments.');
        openCommentModal(remoteId);
      } else if(action === 'delete'){
        if(!ann) return alert('Not found');
        if(!confirm('Delete this annotation?')) return;
        const idx = anns.findIndex(a => String(a.id) === String(ann.id));
        if(idx !== -1){ anns.splice(idx,1); saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations(); }
        try{ if(ann._remoteId) await deleteAnnotationRemote(ann._remoteId); }catch(e){ console.warn('remote delete failed', e); alert('Remote delete failed'); }
      }
    });
  });
}

/* COMMENT modal logic (persistent outside re-renders) */
let currentCommentRemoteId = null;
$('#close-comments').addEventListener('click', ()=>{ $('#comment-modal').style.display='none'; currentCommentRemoteId = null; $('#comments-list').innerHTML = '<div class="small">No comments loaded.</div>'; });

async function openCommentModal(remoteId){
  currentCommentRemoteId = remoteId;
  $('#comment-modal').style.display = 'block';
  $('#comments-list').innerHTML = '<div class="small">Loading…</div>';
  try{
    const snap = await db.collection('annotations').doc(remoteId).collection('comments').orderBy('created_at','asc').get();
    const comments = [];
    snap.forEach(d => { comments.push({ id:d.id, ...d.data() }); });
    if(comments.length === 0) $('#comments-list').innerHTML = '<div class="small">No comments yet.</div>';
    else {
      $('#comments-list').innerHTML = '';
      for(const c of comments){
        const item = el('div',{className:'comment-item'}, `<strong style="font-size:12px">${escapeHtml(c.author||'Anonymous')}</strong> <div style="font-size:12px;color:var(--muted-2)">${new Date(c.created_at?.toDate ? c.created_at.toDate() : c.created_at).toLocaleString()}</div><div style="margin-top:6px">${escapeHtml(c.text)}</div>`);
        $('#comments-list').appendChild(item);
      }
    }
  }catch(e){ console.error('openCommentModal error', e); $('#comments-list').innerHTML = '<div class="small">Could not load comments.</div>'; }
}

$('#post-comment').addEventListener('click', async ()=>{
  const text = $('#comment-text').value.trim();
  if(!text) return alert('Write something');
  if(!currentCommentRemoteId) return alert('No annotation selected.');
  const doc = { text, author: 'Stacy', created_at: firebase.firestore.FieldValue.serverTimestamp() };
  try{
    await db.collection('annotations').doc(currentCommentRemoteId).collection('comments').add(doc);
    $('#comment-text').value = '';
    // append locally
    const item = el('div',{className:'comment-item'}, `<strong style="font-size:12px">${escapeHtml('Stacy')}</strong> <div style="font-size:12px;color:var(--muted-2)">${(new Date()).toLocaleString()}</div><div style="margin-top:6px">${escapeHtml(text)}</div>`);
    if($('#comments-list').querySelector('.small')) $('#comments-list').innerHTML = '';
    $('#comments-list').appendChild(item);
  }catch(e){ console.error('post comment failed', e); alert('Comment failed'); }
});

/* selection -> display offset mapping helpers */
function collectTextNodes(root){
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
  const arr = [];
  let n;
  while(n = walker.nextNode()){
    arr.push(n);
  }
  return arr;
}

/* convert DOM Range start to display char offset (based on DOM text nodes) */
function displayOffsetFromRange(range){
  try{
    if(!range) return null;
    const container = document.getElementById('article');
    const nodes = collectTextNodes(container);
    let chars = 0;
    for(const node of nodes){
      if(node === range.startContainer){
        return chars + range.startOffset;
      }
      chars += node.textContent.length;
    }
    // fallback: walk parents to find nearest text node
    let sc = range.startContainer;
    while(sc && sc !== container){
      if(sc.nodeType === Node.TEXT_NODE){
        chars = 0;
        for(const node of nodes){
          if(node === sc) return chars + range.startOffset;
          chars += node.textContent.length;
        }
      }
      sc = sc.parentNode;
    }
    return null;
  }catch(e){ console.warn('displayOffsetFromRange error', e); return null; }
}

/* convert display offset/length to raw start/end using mapping computed earlier */
function displayToRawRange(displayStart, length){
  const map = window.current.displayToRawMap || [];
  const displayText = window.current.displayText || '';
  if(displayStart === null || displayStart === undefined) return null;
  const start = Math.max(0, Math.min(displayText.length-1, displayStart));
  const lastIndex = Math.max(0, Math.min(displayText.length-1, displayStart + length - 1));
  const rawStart = map[start];
  const rawEnd = (map[lastIndex] !== undefined) ? (map[lastIndex] + 1) : ( (map[start] !== undefined) ? (map[start] + length) : null );
  if(rawStart === undefined || rawEnd === undefined || rawEnd <= rawStart) return null;
  return { start_idx: rawStart, end_idx: rawEnd };
}

/* fallback: find indices in displayText (normalized) */
function findAllIndicesInDisplay(display, needle){
  const res = [];
  if(!needle) return res;
  let pos = 0;
  while(true){
    const idx = display.indexOf(needle, pos);
    if(idx === -1) break;
    res.push(idx);
    pos = idx + Math.max(1, needle.length);
  }
  return res;
}

/* DOM range from display char index */
function domRangeForDisplayIndex(container, displayIndex, length){
  const nodes = collectTextNodes(container);
  let chars = 0;
  const range = document.createRange();
  for(const node of nodes){
    const next = chars + node.textContent.length;
    if(displayIndex < next){
      const startOffset = Math.max(0, displayIndex - chars);
      range.setStart(node, startOffset);
      if(length <= node.textContent.length - startOffset){
        range.setEnd(node, startOffset + length);
        return range;
      }
      let remaining = length - (node.textContent.length - startOffset);
      let fw = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
      let n;
      while((n = fw.nextNode())){
        if(n === node) break;
      }
      while((n = fw.nextNode())){
        if(remaining <= n.textContent.length){ range.setEnd(n, remaining); return range; }
        remaining -= n.textContent.length;
      }
      range.setEnd(node, node.textContent.length);
      return range;
    }
    chars = next;
  }
  return null;
}

/* compute selection robustly: uses display mapping first, fallback to text search+rect distance */
const articleEl = document.getElementById('article');
const annotFab = document.getElementById('annot-fab');
const lookupBtn = document.getElementById('lookup-btn');

function hideFabAndLookup(){ annotFab.style.display='none'; lookupBtn.style.display='none'; }

/* position helpers */
function showFabAtRect(rect){
  if(!rect) return hideFabAndLookup();
  const scrollY = window.scrollY || window.pageYOffset;
  const left = Math.max(8, rect.left + (rect.width/2) - 40);
  const top = rect.top + scrollY - 44;
  annotFab.style.left = left + 'px';
  annotFab.style.top = top + 'px';
  annotFab.style.display = 'block';
  // lookup button slightly above
  lookupBtn.style.left = (left + 80) + 'px';
  lookupBtn.style.top = (top) + 'px';
  lookupBtn.style.display = 'block';
}

/* capture selection into pendingSelection using mapping */
function captureSelectionFromRange(range){
  const selText = range.toString();
  if(!selText || !window.current.raw) return null;

  // try display mapping route
  const displayStart = displayOffsetFromRange(range);
  if(displayStart !== null){
    const dr = displayToRawRange(displayStart, selText.length);
    if(dr){
      pendingSelection = { start_idx: dr.start_idx, end_idx: dr.end_idx, text: window.current.raw.slice(dr.start_idx, dr.end_idx) };
      return pendingSelection;
    }
  }

  // fallback to searching in displayText (normalized) and choosing nearest rect
  const displayText = normalizeForMatching(window.current.displayText || '');
  const needle = normalizeForMatching(selText);
  const indices = findAllIndicesInDisplay(displayText, needle);
  if(indices.length === 0) { pendingSelection = null; return null; }
  // compute best by rect distance
  const selRect = range.getBoundingClientRect();
  let best = null; let bestDist = Infinity;
  for(const idx of indices){
    const drange = domRangeForDisplayIndex(articleEl, idx, selText.length);
    if(!drange) continue;
    const r = drange.getBoundingClientRect();
    if(!r || (r.width===0 && r.height===0)) continue;
    const d = rectDistance(selRect, r);
    if(d < bestDist){ bestDist = d; best = { idx, range: drange, rect: r }; }
  }
  if(!best){ pendingSelection = null; return null; }
  const rawRange = displayToRawRange(best.idx, selText.length);
  if(!rawRange){ pendingSelection = null; return null; }
  pendingSelection = { start_idx: rawRange.start_idx, end_idx: rawRange.end_idx, text: window.current.raw.slice(rawRange.start_idx, rawRange.end_idx) };
  return pendingSelection;
}

/* rect distance */
function rectDistance(a,b){ const ax=a.left+a.width/2, ay=a.top+a.height/2, bx=b.left+b.width/2, by=b.top+b.height/2; return Math.hypot(ax-bx, ay-by); }

/* selectionchange logic */
document.addEventListener('selectionchange', onSelectionChange);
document.addEventListener('pointerup', onSelectionChange);

function onSelectionChange(){
  const sel = window.getSelection();
  const editorOpen = document.getElementById('annotation-editor').style.display === 'block';
  if(!sel || sel.rangeCount === 0){ if(editorOpen) return; pendingSelection = null; hideFabAndLookup(); return; }
  const range = sel.getRangeAt(0);
  const text = sel.toString();
  if(!text || !window.current.raw){ if(editorOpen) return; pendingSelection = null; hideFabAndLookup(); return; }

  // try to capture selection
  const cap = captureSelectionFromRange(range);
  if(!cap){ if(editorOpen) return; pendingSelection = null; hideFabAndLookup(); return; }

  // compute rect for placement
  const selRect = range.getBoundingClientRect();
  if(selRect && selRect.width>0 && selRect.height>0){
    if(window.innerWidth < 980){ annotFab.style.position='fixed'; lookupBtn.style.position='fixed'; annotateFabFixedPlacement(); }
    else { annotFab.style.position='absolute'; lookupBtn.style.position='absolute'; showFabAtRect(selRect); }
  } else {
    // fallback to fixed placement if rect is zero-sized (end of doc)
    annotFab.style.position='fixed'; lookupBtn.style.position='fixed';
    annotateFabFixedPlacement();
  }

  // Only show lookup button for single-token selections (no whitespace)
  if(/^\S+$/.test(text.trim())) lookupBtn.style.display = 'block';
  else lookupBtn.style.display = 'none';
}

function annotateFabFixedPlacement(){
  annotFab.style.right = '14px'; annotFab.style.bottom = '110px'; annotFab.style.left = ''; annotFab.style.top = ''; annotFab.style.display='block';
  lookupBtn.style.right = '14px'; lookupBtn.style.bottom = '150px'; lookupBtn.style.left = ''; lookupBtn.style.top = ''; // slightly above
  lookupBtn.style.display = 'none'; // become visible if single-token
}

/* prevent selection loss on FAB click - capture selection on mousedown */
annotFab.addEventListener('pointerdown', (ev)=>{
  ev.preventDefault(); // important: prevents selection collapse in many browsers
  const sel = window.getSelection();
  if(!sel || sel.rangeCount===0) return;
  const range = sel.getRangeAt(0);
  captureSelectionFromRange(range);
});

/* when annotate clicked, open editor. The pointerdown has already captured selection. */
annotFab.addEventListener('click', ()=>{
  if(!pendingSelection) return alert('No selection.');
  $('#selection-preview').innerText = `"${pendingSelection.text.slice(0,120)}${pendingSelection.text.length>120?'…':''}"`;
  $('#annotation-text').value = '';
  $('#annotation-editor').style.display = 'block';
  $('#annotation-editor').dataset.editing = '';
  $('#delete-annotation').style.display = 'none';
  $('#annotation-editor').dataset.remoteId = '';
  document.getElementById('right-col').classList.remove('collapsed');
  document.getElementById('right-col').scrollTop = 0;
  hideFabAndLookup();
});

/* lookup button handlers: pointerdown prevents selection loss too */
lookupBtn.addEventListener('pointerdown', (ev)=>{ ev.preventDefault(); });
lookupBtn.addEventListener('click', ()=>{
  const sel = window.getSelection(); if(!sel || sel.rangeCount===0) return;
  const text = sel.toString().trim();
  if(!text) return alert('No selection.');
  // show definition modal
  lookupDefinition(text);
  hideFabAndLookup();
});

/* dictionary lookup */
async function lookupDefinition(word){
  $('#define-content').innerHTML = '<div class="small">Looking up…</div>';
  $('#define-modal').style.display = 'block';
  try{
    const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word)}`);
    if(!res.ok) throw new Error('Not found');
    const data = await res.json();
    const entry = data[0] || {};
    const meanings = entry.meanings || [];
    let html = `<div style="font-weight:700">${escapeHtml(entry.word||word)} ${entry.phonetics && entry.phonetics[0] ? '('+escapeHtml(entry.phonetics[0].text)+')' : ''}</div>`;
    if(meanings.length>0){
      const m = meanings[0];
      html += `<div style="margin-top:6px;font-size:13px">${escapeHtml(m.partOfSpeech||'')}</div>`;
      const defs = m.definitions || [];
      if(defs.length>0){
        html += `<div style="margin-top:6px">${escapeHtml(defs[0].definition||'')}</div>`;
        if(defs[0].example) html += `<div class="small" style="margin-top:6px;color:var(--muted-2)">Example: ${escapeHtml(defs[0].example)}</div>`;
      }
    } else {
      html += `<div class="small">No meaning found.</div>`;
    }
    $('#define-content').innerHTML = html;
  }catch(e){
    $('#define-content').innerHTML = `<div class="small">No definition found for "${escapeHtml(word)}".</div>`;
  }
}
$('#close-define').addEventListener('click', ()=>{ $('#define-modal').style.display='none'; });

/* Firestore helpers */
async function pushAnnotationToFirestore(payload){
  try{
    const doc = {
      file: normalizePath(payload.file),
      start_idx: Number(payload.start_idx),
      end_idx: Number(payload.end_idx),
      text: payload.text || "",
      note: payload.note || "",
      author: payload.author || "Stacy",
      created_at: firebase.firestore.FieldValue.serverTimestamp()
    };
    const ref = await db.collection('annotations').add(doc);
    return { ok:true, id: ref.id };
  }catch(e){
    console.error('pushAnnotation error', e);
    return { ok:false, error:e };
  }
}

async function updateAnnotationRemote(remoteId, updateObj){
  try{
    await db.collection('annotations').doc(remoteId).update(updateObj);
    return { ok:true };
  }catch(e){ console.warn('updateAnnotationRemote failed', e); return { ok:false, error:e }; }
}

async function deleteAnnotationRemote(remoteId){
  try{ await db.collection('annotations').doc(remoteId).delete(); return { ok:true }; }
  catch(e){ console.warn('deleteAnnotationRemote failed', e); return { ok:false, error:e }; }
}

/* Save & edit annotations */
$('#cancel-annotation').addEventListener('click', ()=>{ pendingSelection = null; $('#annotation-editor').style.display='none'; $('#annotation-editor').dataset.editing=''; $('#annotation-editor').dataset.remoteId=''; window.getSelection().removeAllRanges(); hideFabAndLookup(); });

$('#delete-annotation').addEventListener('click', async ()=>{
  const editingId = $('#annotation-editor').dataset.editing;
  if(!editingId) return alert('No annotation selected for deletion');
  if(!confirm('Delete this annotation?')) return;
  let anns = loadAnnsLocal(window.current.filePath) || [];
  const idx = anns.findIndex(a=> String(a.id) === String(editingId));
  const ann = anns[idx];
  if(idx !== -1){ anns.splice(idx,1); saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations(); }
  $('#annotation-editor').style.display='none'; $('#annotation-editor').dataset.editing=''; $('#annotation-editor').dataset.remoteId='';
  try{ if(ann && ann._remoteId) await deleteAnnotationRemote(ann._remoteId); }catch(e){ console.warn('remote delete failed', e); alert('Remote delete failed'); }
});

$('#save-annotation').addEventListener('click', async ()=>{
  if(!window.current.filePath) return alert('Open a reading first.');
  let noteRaw = $('#annotation-text').value.trim(); if(!noteRaw) return alert('Write a note.');
  const editingId = $('#annotation-editor').dataset.editing;
  const nowISO = new Date().toISOString();
  let anns = loadAnnsLocal(window.current.filePath) || [];

  // parse possible "Taru " prefix
  function parseNoteAuthor(rawNote){
    if(!rawNote) return { note: rawNote, author: undefined };
    const m = rawNote.match(/^\s*(Taru)\s+(.*)$/i);
    if(m){ return { note: m[2].trim(), author: m[1] }; }
    return { note: rawNote, author: undefined };
  }
  const parsed = parseNoteAuthor(noteRaw);
  const finalNote = parsed.note;
  const finalAuthor = parsed.author;

  if(editingId){
    const idx = anns.findIndex(a=> String(a.id) === String(editingId));
    if(idx === -1) return alert('Annotation not found.');
    anns[idx].note = finalNote;
    if(finalAuthor) anns[idx].author = finalAuthor;
    anns[idx].edited_at = nowISO;
    saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations();

    try{
      const remoteId = anns[idx]._remoteId;
      if(remoteId){
        const updateObj = { note: finalNote, edited_at: nowISO };
        if(finalAuthor) updateObj.author = finalAuthor;
        const upd = await updateAnnotationRemote(remoteId, updateObj);
        if(!upd.ok){
          try{ await deleteAnnotationRemote(remoteId); }catch(e){}
          const newPush = await pushAnnotationToFirestore(anns[idx]);
          if(newPush.ok){ anns[idx]._remoteId = newPush.id; saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations(); }
        }
      } else {
        const res = await pushAnnotationToFirestore(anns[idx]);
        if(res.ok){ anns[idx]._remoteId = res.id; saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations(); }
      }
    }catch(e){ console.warn('remote edit failed', e); }
  } else {
    // create new: ensure we have pendingSelection (pointerdown on FAB should have set it)
    if(!pendingSelection) return alert('Select text first.');
    const startIdx = Math.floor(pendingSelection.start_idx);
    const endIdx = Math.floor(pendingSelection.end_idx);

    // If an annotation already exists with exact same start & end, open editor instead of duplicating
    const existingExact = anns.find(a => Number(a.start_idx) === startIdx && Number(a.end_idx) === endIdx);
    if(existingExact){
      // open editor for that annotation
      $('#annotation-editor').style.display = 'block';
      $('#annotation-editor').dataset.editing = existingExact.id;
      $('#annotation-text').value = existingExact.note || '';
      $('#selection-preview').innerText = `"${pendingSelection.text.slice(0,120)}${pendingSelection.text.length>120?'…':''}"`;
      $('#delete-annotation').style.display = 'inline-block';
      $('#delete-annotation').dataset.remoteId = existingExact._remoteId || '';
      return;
    }

    const newAnn = {
      id: String(Date.now()) + '-' + Math.floor(Math.random()*9999),
      file: window.current.filePath,
      start_idx: startIdx,
      end_idx: endIdx,
      text: pendingSelection.text,
      note: finalNote,
      author: finalAuthor || 'Stacy',
      created_at: nowISO
    };
    anns.push(newAnn); saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations();

    const res = await pushAnnotationToFirestore(newAnn);
    if(!res.ok){ console.warn('Firestore write failed', res.error); alert('Firestore write failed; saved locally.'); }
    else { const loc = loadAnnsLocal(window.current.filePath); const li = loc.find(a=> a.id === newAnn.id); if(li){ li._remoteId = res.id; saveAnnsLocal(window.current.filePath, loc); renderArticleWithAnnotations(); } }
  }

  $('#annotation-editor').style.display = 'none'; $('#annotation-editor').dataset.editing = ''; pendingSelection = null; window.getSelection().removeAllRanges(); hideFabAndLookup();
});

/* fetch + realtime */
async function fetchAnnotationsOnce(filePath){
  if(!filePath) return;
  try{
    const snap = await db.collection('annotations').where('file','==', normalizePath(filePath)).get();
    const anns = [];
    snap.forEach(doc => { const d = doc.data(); d._remoteId = doc.id; d.id = d.id || doc.id; anns.push(d); });
    anns.sort((a,b)=> {
      const ta = a.created_at?.toDate ? a.created_at.toDate().toISOString() : (a.created_at || a.createdAt || '');
      const tb = b.created_at?.toDate ? b.created_at.toDate().toISOString() : (b.created_at || b.createdAt || '');
      return (ta||'').localeCompare(tb||'');
    });
    saveAnnsLocal(filePath, anns);
    renderArticleWithAnnotations();
    return anns;
  }catch(e){ console.error('fetchAnnotationsOnce error', e); return null; }
}

function subscribeRealtime(filePath){
  if(unsubscribeRealtime){ try{ unsubscribeRealtime(); }catch(e){} unsubscribeRealtime = null; }
  if(pollingFallback){ clearInterval(pollingFallback); pollingFallback = null; }
  try{
    unsubscribeRealtime = db.collection('annotations').where('file','==', normalizePath(filePath)).orderBy('created_at').onSnapshot(snapshot=>{
      const anns = [];
      snapshot.forEach(doc => { const d = doc.data(); d._remoteId = doc.id; d.id = d.id || doc.id; anns.push(d); });
      anns.sort((a,b)=> {
        const ta = a.created_at?.toDate ? a.created_at.toDate().toISOString() : (a.created_at || a.createdAt || '');
        const tb = b.created_at?.toDate ? b.created_at.toDate().toISOString() : (b.created_at || b.createdAt || '');
        return (ta||'').localeCompare(tb||'');
      });
      saveAnnsLocal(filePath, anns);
      renderArticleWithAnnotations();
    }, err=>{
      console.error('onSnapshot error', err);
      if(pollingFallback) clearInterval(pollingFallback);
      pollingFallback = setInterval(()=> fetchAnnotationsOnce(filePath), 6000);
    });
  }catch(e){ console.warn('subscribeRealtime error', e); if(pollingFallback) clearInterval(pollingFallback); pollingFallback = setInterval(()=> fetchAnnotationsOnce(filePath), 6000); }
}

/* highlight click opens annotation list and scrolls */
document.addEventListener('click', (ev)=>{
  const t = ev.target;
  if(t && t.matches && t.matches('.hl')){
    const start = parseInt(t.getAttribute('data-start')), end = parseInt(t.getAttribute('data-end'));
    if(isNaN(start) || isNaN(end)) return;
    $('#right-col').classList.remove('collapsed');
    document.getElementById('right-col').scrollTop = 0;
    const anns = loadAnnsLocal(window.current.filePath) || [];
    renderAnnGroups(anns);
    setTimeout(()=>{
      const snippet = window.current.raw.slice(start, Math.min(end, start+60)).trim().slice(0,40);
      const groups = Array.from(document.querySelectorAll('#annotations-list .ann-group'));
      for(const g of groups){
        if(g.textContent && g.textContent.includes(snippet)){
          g.scrollIntoView({behavior:'smooth', block:'center'});
          g.animate([{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:500});
          break;
        }
      }
    },150);
  }
});

/* collapse buttons */
$('#collapse-left').addEventListener('click', ()=>{ $('#left-col').classList.toggle('collapsed'); });
$('#collapse-right').addEventListener('click', ()=>{ $('#right-col').classList.toggle('collapsed'); });

/* init reading loader */
async function loadReading(r){
  const url = r.download_url || `/${r.path}`;
  $('#post-title').innerText = r.title || r.path.split('/').pop();
  window.current.filePath = normalizePath(r.path);
  try{
    const res = await fetch(url, {cache:'no-store'});
    if(!res.ok) throw new Error('fetch failed');
    window.current.raw = await res.text();
    window.current.title = r.title || r.path.split('/').pop();
    await fetchAnnotationsOnce(window.current.filePath);
    renderArticleWithAnnotations();
    subscribeRealtime(window.current.filePath);
  }catch(e){
    $('#article').innerHTML = `<div class="small">Error loading ${escapeHtml(url)}</div>`;
    console.error('loadReading error', e);
  }
}

function queryParam(name){ const params = new URLSearchParams(window.location.search); return params.get(name); }

async function initApp(){
  await discoverReadings();
  const fileQuery = queryParam('file');
  if(fileQuery){
    const match = readings.find(r => normalizePath(r.path) === normalizePath(fileQuery) || r.path === fileQuery);
    if(match) { loadReading(match); return; }
    const synthetic = { path: fileQuery, title: fileQuery.split('/').pop(), download_url: `/${fileQuery}` };
    loadReading(synthetic);
    return;
  }
  if(readings.length > 0) loadReading(readings[0]);
  else { $('#article').innerHTML = '<div class="small">No readings found in /readings/. Add files or index.json.</div>'; }
}

/* Small utility: when user double-clicks, don't use confirm; instead do nothing special (we use lookup button now) */
document.addEventListener('dblclick', (e)=>{ /* no-op to avoid native lookup/popups */ });

/* small safety: if user clicks outside selection, hide the fab/buttons */
document.addEventListener('mousedown', (e)=>{ if(e.target === annotFab || annotFab.contains(e.target) || e.target === lookupBtn || lookupBtn.contains(e.target)) return; const sel = window.getSelection(); if(!sel || sel.toString().trim()==='') hideFabAndLookup(); });

/* ---------- End of main script ---------- */
</script>
</body>
</html>
