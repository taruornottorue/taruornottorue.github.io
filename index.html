<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Readings</title>

<!-- markdown renderer + firebase -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

<style>
:root{--bg:#0f0b08;--panel:#17120f;--muted:#c9b89a;--muted-2:#7b6a58;--accent:#b36b2c;--glass:rgba(255,255,255,0.02);--highlight:rgba(179,107,44,0.18);--radius:12px}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--muted);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial}
header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;border-bottom:1px solid rgba(255,255,255,0.02)}
h1{margin:0;font-size:16px}
.app{display:flex;height:calc(100vh - 64px);gap:16px;padding:16px}
.col{background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.01));border-radius:var(--radius);padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);overflow:auto;position:relative}
.left{width:280px;flex-shrink:0}.center{flex:1;min-width:320px}.right{width:320px;flex-shrink:0}
/* collapsed state: leave only the collapse icon visible and center it */
.col.collapsed{width:44px !important;padding:6px !important;overflow:visible !important}
.col.collapsed .panel-body{display:none}
.col.collapsed .panel-header .title-wrap{display:none}
.col.collapsed .panel-header{justify-content:center}
.col.collapsed .panel-header .collapse-icon{display:inline-flex}

.panel-mini{display:none;font-size:16px}
/* reading list */
.reading-item{padding:14px;border-radius:8px;background:var(--glass);margin-bottom:8px;cursor:pointer;display:flex;align-items:center;justify-content:center}
.reading-title{font-weight:600}
.small{font-size:12px;color:var(--muted-2)}
#article{line-height:1.6;color:var(--muted);padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent);outline:none}
.hl{background:var(--highlight);border-radius:4px;padding:0 2px;cursor:pointer}
.ann-group{margin-bottom:12px;border-radius:8px;padding:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
.ann-tabs{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px}
.ann-tab{padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);cursor:pointer;font-size:13px;color:var(--muted-2)}
.ann-active{background:linear-gradient(90deg,var(--accent), #8a5a2a);color:#fff;border:none}
.annotation-editor{margin-bottom:12px}
textarea{width:100%;min-height:88px;border-radius:8px;padding:8px;background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}
#annot-fab{position:absolute;z-index:9999;display:none;padding:8px 12px;border-radius:999px;background:linear-gradient(90deg,var(--accent), #8a5a2a);color:white;border:none;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,0.5);font-weight:600}
/* collapse / icon buttons (gloomy aesthetic) */
.collapse-btn{background:rgba(255,255,255,0.03);color:var(--muted);border:1px solid rgba(255,255,255,0.02);padding:6px;border-radius:8px;cursor:pointer}
.collapse-icon{width:30px;height:30px;display:inline-flex;align-items:center;justify-content:center;border-radius:6px;font-weight:700;padding:0}
/* top-of-panel icon placements */
.panel-header {
  display:flex;justify-content:space-between;align-items:center;margin-bottom:8px
}
.panel-header .title-wrap{display:flex;flex-direction:column}
/* annotations list styles */
#annotations-list .ann-group .ann-tabs{margin-bottom:6px}
/* pw overlay */
#pw-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#000;z-index:100000}
#pw-box{width:420px;background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.01));padding:26px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 20px 80px rgba(0,0,0,0.8);text-align:center}
#pw-box h3{margin:0 0 8px 0;color:var(--muted);font-size:18px}
#pw-box .pw-note{color:var(--muted-2);font-size:13px;margin-bottom:12px}
#pw-box input{width:100%;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);margin-top:6px}
#pw-submit{width:160px;padding:10px;border-radius:10px;border:none;margin-top:12px;background:linear-gradient(90deg,var(--accent), #8a5a2a);color:white;font-weight:700;cursor:pointer}

/* scrollbar (dark theme) */
/* WebKit */
::-webkit-scrollbar{width:10px;height:10px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:linear-gradient(180deg, rgba(179,107,44,0.18), rgba(179,107,44,0.12));border-radius:10px;border:2px solid rgba(0,0,0,0)}
/* Firefox */
*{scrollbar-width:thin;scrollbar-color: rgba(179,107,44,0.18) transparent}

@media (max-width:980px){.app{flex-direction:column;height:calc(100vh - 88px);padding:10px}#annot-fab{position:fixed;right:14px;bottom:90px} }
</style>
</head>
<body>

<header>
  <div style="display:flex;gap:12px;align-items:center"><h1>Readings</h1><div class="small">(and also annotating if you wish to)</div></div>
  <div style="display:flex;gap:8px;align-items:center">
    <!-- sync status intentionally hidden for cleaner UI -->
  </div>
</header>

<div class="app">
  <aside class="col left" id="left-col">
    <div class="panel-header">
      <div class="title-wrap"><div class="small">Primarily just short stories</div><strong style="font-size:15px">Readings</strong></div>
      <!-- collapse icon inside the panel (moved from header) -->
      <button class="collapse-btn collapse-icon" id="collapse-left" title="Toggle left">O</button>
    </div>

    <div class="panel-body">
      <div id="reading-list"><div class="small">Loading…</div></div>
      <hr style="border:none;height:1px;background:rgba(255,255,255,0.02);margin:12px 0" />
      <!-- index path & debug hidden to keep UI clean -->
      <div id="index-json-path" style="display:none;margin-top:6px;color:var(--muted-2)"></div>
      <div id="debug-block" style="display:none"></div>
    </div>
  </aside>

  <main class="col center">
    <!-- simplified header: only title visible -->
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
      <div><h2 id="post-title" style="margin:4px 0 0 0">Nothing loaded</h2></div>
      <div style="text-align:right"><div id="current-file" class="small" style="display:none">—</div></div>
    </div>
    <div id="article" tabindex="0" aria-label="Article content"><div class="small">Open a reading from the left.</div></div>
  </main>

  <aside class="col right" id="right-col">
    <div class="panel-header">
      <div class="title-wrap"><strong style="font-size:15px">Annotations</strong></div>
      <!-- collapse icon inside panel -->
      <button class="collapse-btn collapse-icon" id="collapse-right" title="Toggle right">X</button>
    </div>

    <div class="panel-body">
      <div id="annotation-editor" class="annotation-editor" style="display:none">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Add annotation</strong></div>
          <div class="small" id="selection-preview"></div>
        </div>
        <textarea id="annotation-text" placeholder="Write your note."></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button class="collapse-btn" id="save-annotation">Save</button>
          <button class="collapse-btn" id="cancel-annotation">Cancel</button>
        </div>
        <div class="small" style="margin-top:8px;color:var(--muted-2)">Saved locally immediately; Firestore sync happens automatically.</div>
      </div>

      <div id="annotations-list"><div class="small">Select text to create an annotation.</div></div>
    </div>
  </aside>
</div>

<button id="annot-fab">Annotate</button>

<div id="pw-overlay">
  <div id="pw-box">
    <h3>Password</h3>
    <div class="pw-note">I don't know why I added this</div>
    <input id="pw-input" placeholder="Password" autocomplete="off"/>
    <div style="display:flex;justify-content:center">
      <button id="pw-submit">Unlock</button>
    </div>
  </div>
</div>

<script>
/*
  Final polish as requested:
  - collapsing left/right hides all internal text and leaves only the O/X icon centered
  - password overlay restored to dark backdrop, centered dialog
  - heading 'Password' and short note text
  - removed Guest button; Unlock button centered and larger
  - Enter key on password input triggers unlock
  - fixed earlier broken newline regex in buildAnnotatedHtml
*/

/* CONFIG — edit these */
const PASSWORD = "Stacy"; // change this
const READINGS_PATH = "readings";   // change if different
/* Paste your Firebase web config here */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyCxhiw5V3epzzWeFxlMGQ8SH4QjWDjH_1A",
  authDomain: "taruornottorue.firebaseapp.com",
  projectId: "taruornottorue",
  // OPTIONAL: storageBucket, messagingSenderId, appId...
  storageBucket: "taruornottorue.firebasestorage.app",
  messagingSenderId: "458061841918",
  appId: "1:458061841918:web:1cc68c086bcbf81ee3acaf"
};


firebase.initializeApp(FIREBASE_CONFIG);
const db = firebase.firestore();

/* small utils */
const $ = s => document.querySelector(s);
const el = (t,a={},h='') => { const e = document.createElement(t); Object.assign(e,a); if(h) e.innerHTML = h; return e; };
function escapeHtml(s){ return (s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;'); }

/* app state */
window.appState = window.appState || {};
let readings = [];
window.current = window.current || { filePath: null, raw: null, title: null };
let pendingSelection = null;
let unsubscribeRealtime = null;
let pollingFallback = null;

/* password overlay */
function isUnlocked(){ try{ return sessionStorage.getItem('candle_unlocked') === '1'; }catch(e){return false;} }
function setUnlocked(){ try{ sessionStorage.setItem('candle_unlocked','1'); }catch(e){} }
function showOverlay(){ $('#pw-overlay').style.display='flex'; document.body.style.overflow='hidden'; $('#pw-input').focus(); }
function hideOverlay(){ $('#pw-overlay').style.display='none'; document.body.style.overflow=''; }

if(!isUnlocked()) showOverlay(); else initApp();
$('#pw-submit').addEventListener('click', ()=>{ if($('#pw-input').value === PASSWORD){ setUnlocked(); hideOverlay(); initApp(); } else alert('Wrong password'); });
// Enter key triggers unlock
$('#pw-input').addEventListener('keydown', (e)=>{ if(e.key === 'Enter') $('#pw-submit').click(); });

function normalizePath(p){ if(!p) return p; return p.startsWith('/') ? p.slice(1) : p; }

/* discover readings from index.json (robust) */
async function discoverReadings(){
  const indexPath = `/${READINGS_PATH}/index.json`;
  try{
    const r = await fetch(indexPath, {cache:'no-store'});
    if(r.ok){
      const arr = await r.json();
      // support either array of strings or array of objects
      readings = arr.map(item => {
        if(typeof item === 'string') return { path: item, title: item.split('/').pop() };
        return { path: item.path, title: item.title || item.path.split('/').pop(), download_url: item.download_url };
      });
      renderReadingList();
      return;
    }
  }catch(e){ console.warn('discoverReadings error', e); }
  $('#reading-list').innerHTML = '<div class="small">No readings found. Add /readings/index.json</div>';
}

function renderReadingList(){
  const cont = $('#reading-list'); cont.innerHTML = '';
  readings.forEach(r=>{
    const item = el('div',{className:'reading-item'});
    // Show only the title centered (no filename or "Open")
    item.innerHTML = `<div style="text-align:center;width:100%"><div class="reading-title">${escapeHtml(r.title)}</div></div>`;
    item.addEventListener('click', ()=> loadReading(r));
    cont.appendChild(item);
  });
}

/* load a reading */
async function loadReading(r){
  const url = r.download_url || `/${r.path}`;
  $('#post-title').innerText = r.title || r.path.split('/').pop();
  window.current.filePath = normalizePath(r.path);
  try{
    const res = await fetch(url, {cache:'no-store'});
    if(!res.ok) throw new Error('fetch failed');
    window.current.raw = await res.text();
    window.current.title = r.title || r.path.split('/').pop();
    await fetchAnnotationsOnce(window.current.filePath);
    renderArticleWithAnnotations();
    subscribeRealtime(window.current.filePath);
  }catch(e){
    $('#article').innerHTML = `<div class="small">Error loading ${escapeHtml(url)}</div>`;
    console.error('loadReading error', e);
  }
}

/* local storage helpers */
const STORAGE_PREFIX = 'candle_annot_';
function annKeyFor(fp){ return STORAGE_PREFIX + 'anns::' + fp; }
function loadAnnsLocal(fp){ try{ const s = localStorage.getItem(annKeyFor(fp)); return s ? JSON.parse(s) : []; }catch(e){ return []; } }
function saveAnnsLocal(fp, arr){ localStorage.setItem(annKeyFor(fp), JSON.stringify(arr)); }

/* build annotated html (groups by identical start/end so multiple notes attach to same span) */
function buildAnnotatedHtml(text, anns){
  anns = (anns || []).slice().sort((a,b)=> (a.start_idx||a.start) - (b.start_idx||b.start));
  const groups = [];
  for(const a of anns){
    const start = a.start_idx ?? a.start;
    const end = a.end_idx ?? a.end;
    const last = groups.length ? groups[groups.length-1] : null;
    if(last && last.start === start && last.end === end) last.items.push(a);
    else groups.push({ start, end, items: [a] });
  }
  let out = '', cursor = 0;
  for(const g of groups){
    if(g.start > cursor) out += escapeHtml(text.slice(cursor, g.start));
    const excerpt = escapeHtml(text.slice(g.start, g.end));
    const ids = g.items.map(i=>i.id).join(',');
    out += `<span class="hl" tabindex="0" data-ann-ids="${ids}" data-start="${g.start}" data-end="${g.end}">${excerpt}</span>`;
    cursor = g.end;
  }
  if(cursor < text.length) out += escapeHtml(text.slice(cursor));
  out = out.replace(/
{2,}/g, '</p><p>').replace(/
/g, '<br>');
  return `<p>${out}</p>`;
}

function renderArticleWithAnnotations(){
  const raw = window.current.raw || '';
  const anns = loadAnnsLocal(window.current.filePath) || [];
  $('#article').innerHTML = buildAnnotatedHtml(raw, anns);
  renderAnnGroups(anns);
}

/* render annotation groups: simplified UI — no dates, no delete; author hardcoded to Stacy */
function renderAnnGroups(anns){
  const cont = $('#annotations-list'); cont.innerHTML = '';
  if(!anns || anns.length===0){ cont.innerHTML = '<div class="small">No annotations yet.</div>'; return; }
  anns = anns.slice().sort((a,b)=> (a.start_idx||a.start) - (b.start_idx||b.start));
  const groups = [];
  for(const a of anns){
    const start = a.start_idx ?? a.start;
    const end = a.end_idx ?? a.end;
    const last = groups.length ? groups[groups.length-1] : null;
    if(last && last.start === start && last.end === end) last.items.push(a);
    else groups.push({ start, end, items: [a] });
  }
  groups.forEach(g=>{
    const excerpt = window.current.raw.slice(g.start, g.end);
    const groupEl = el('div',{className:'ann-group'});
    groupEl.appendChild(el('div',{}, `<div class="small" style="margin-bottom:8px"><em>Excerpt:</em> "${escapeHtml(excerpt.slice(0,200))}${excerpt.length>200?'…':''}"</div>`));
    const tabs = el('div',{className:'ann-tabs'});
    g.items.forEach((it, idx)=>{
      const tab = el('button',{className:'ann-tab'}, `Stacy`);
      if(idx===0) tab.classList.add('ann-active');
      tab.addEventListener('click', ()=> {
        tabs.querySelectorAll('.ann-tab').forEach(t=>t.classList.remove('ann-active'));
        tab.classList.add('ann-active');
        body.innerHTML = `${marked.parseInline(it.note||'')}<div style="margin-top:8px;display:flex;gap:8px"><button class="collapse-btn" data-id="${it.id}" data-action="jump">Jump</button><button class="collapse-btn" data-id="${it.id}" data-action="edit">Edit</button></div>`;
      });
      tabs.appendChild(tab);
    });
    groupEl.appendChild(tabs);
    const body = el('div',{}, `${marked.parseInline(g.items[0].note||'')}<div style="margin-top:8px;display:flex;gap:8px"><button class="collapse-btn" data-id="${g.items[0].id}" data-action="jump">Jump</button><button class="collapse-btn" data-id="${g.items[0].id}" data-action="edit">Edit</button></div>`);
    groupEl.appendChild(body);
    cont.appendChild(groupEl);
  });

  cont.querySelectorAll('[data-action]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-id'), action = btn.getAttribute('data-action');
      const anns = loadAnnsLocal(window.current.filePath) || [];
      const ann = anns.find(a=> String(a.id) === String(id));
      if(!ann) return alert('Not found');
      if(action === 'jump'){
        const sp = document.querySelector(`[data-ann-ids*="${id}"]`);
        if(sp){ sp.scrollIntoView({behavior:'smooth', block:'center'}); sp.animate([{boxShadow:'0 0 0 rgba(0,0,0,0)'},{boxShadow:'0 10px 40px rgba(179,107,44,0.22)'}],{duration:900}); }
      } else if(action === 'edit'){
        pendingSelection = { start_idx: ann.start_idx ?? ann.start, end_idx: ann.end_idx ?? ann.end, text: window.current.raw.slice(ann.start_idx ?? ann.start, ann.end_idx ?? ann.end) };
        $('#selection-preview').innerText = `"${pendingSelection.text.slice(0,90)}${pendingSelection.text.length>90?'…':''}"`;
        $('#annotation-text').value = ann.note || '';
        $('#annotation-editor').style.display = 'block';
        $('#annotation-editor').dataset.editing = ann.id;
        // ensure right panel expanded when editing
        document.getElementById('right-col').classList.remove('collapsed');
      }
    });
  });
}

/* selection helpers */
function findAllIndices(haystack, needle){ const res=[]; if(!needle) return res; let pos=0; while(true){ const idx = haystack.indexOf(needle,pos); if(idx===-1) break; res.push(idx); pos = idx + Math.max(1, needle.length); } return res; }
function domRangeForCharIndex(container, charIndex, length){ const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false); let node; let chars = 0; while(node = walker.nextNode()){ const next = chars + node.textContent.length; if(charIndex < next){ const startOffset = Math.max(0, charIndex - chars); const range = document.createRange(); range.setStart(node, startOffset); if(length <= node.textContent.length - startOffset){ range.setEnd(node, startOffset + length); return range; } let remaining = length - (node.textContent.length - startOffset); const fw = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false); let n; while((n = fw.nextNode())){ if(n === node) break; } while((n = fw.nextNode())){ if(remaining <= n.textContent.length){ range.setEnd(n, remaining); return range; } remaining -= n.textContent.length; } range.setEnd(node, node.textContent.length); return range; } chars = next; } return null; }
function rectDistance(a,b){ const ax=a.left+a.width/2, ay=a.top+a.height/2, bx=b.left+b.width/2, by=b.top+b.height/2; return Math.hypot(ax-bx, ay-by); }

const articleEl = document.getElementById('article');
const annotFab = document.getElementById('annot-fab');
function hideFab(){ annotFab.style.display='none'; }
function showFabAtRect(rect){ if(!rect) return hideFab(); const scrollY = window.scrollY || window.pageYOffset; const left = Math.max(8, rect.left + (rect.width/2) - 40); const top = rect.top + scrollY - 44; annotFab.style.left = left + 'px'; annotFab.style.top = top + 'px'; annotFab.style.display = 'block'; }

document.addEventListener('selectionchange', ()=>{
  const sel = window.getSelection();
  const editorOpen = document.getElementById('annotation-editor').style.display === 'block';
  if(!sel || sel.rangeCount === 0){ if(editorOpen) return; pendingSelection = null; hideFab(); return; }
  const text = sel.toString();
  if(!text || !window.current.raw){ if(editorOpen) return; pendingSelection = null; hideFab(); return; }
  const indices = findAllIndices(window.current.raw, text);
  if(indices.length === 0){ if(editorOpen) return; pendingSelection = null; hideFab(); return; }
  const selRect = sel.getRangeAt(0).getBoundingClientRect();
  let best = null; let bestDist = Infinity;
  for(const idx of indices){
    const range = domRangeForCharIndex(articleEl, idx, text.length);
    if(!range) continue;
    const r = range.getBoundingClientRect();
    if(!r || (r.width===0 && r.height===0)) continue;
    const d = rectDistance(selRect, r);
    if(d < bestDist){ bestDist = d; best = { index: idx, range, rect: r }; }
  }
  if(!best){ if(editorOpen) return; pendingSelection = null; hideFab(); return; }
  pendingSelection = { start_idx: best.index, end_idx: best.index + text.length, text };
  if(window.innerWidth < 980){ annotFab.style.position='fixed'; annotFab.style.right='14px'; annotFab.style.bottom='110px'; annotFab.style.left=''; annotFab.style.top=''; annotFab.style.display='block'; }
  else { annotFab.style.position='absolute'; showFabAtRect(best.rect); }
});

annotFab.addEventListener('pointerdown', (ev)=>{
  const sel = window.getSelection(); if(!sel || sel.rangeCount===0) return;
  const text = sel.toString(); if(!text || !window.current.raw) return;
  const indices = findAllIndices(window.current.raw, text); if(indices.length === 0) return;
  const selRect = sel.getRangeAt(0).getBoundingClientRect();
  let best=null, bestDist=Infinity;
  for(const idx of indices){
    const range = domRangeForCharIndex(articleEl, idx, text.length);
    if(!range) continue;
    const r = range.getBoundingClientRect();
    const d = rectDistance(selRect, r);
    if(d < bestDist){ bestDist = d; best = { index: idx, rect: r }; }
  }
  if(best) pendingSelection = { start_idx: best.index, end_idx: best.index + text.length, text };
});

annotFab.addEventListener('click', ()=>{
  if(!pendingSelection) return alert('No selection.');
  $('#selection-preview').innerText = `"${pendingSelection.text.slice(0,120)}${pendingSelection.text.length>120?'…':''}"`;
  $('#annotation-text').value = '';
  $('#annotation-editor').style.display = 'block';
  $('#annotation-editor').dataset.editing = '';
  document.getElementById('right-col').classList.remove('collapsed');
  document.getElementById('right-col').scrollTop = 0;
  hideFab();
});

document.addEventListener('mousedown', (e)=>{ if(e.target === annotFab || annotFab.contains(e.target)) return; const sel = window.getSelection(); if(!sel || sel.toString().trim()==='') hideFab(); });

/* Firestore write helper */
async function pushAnnotationToFirestore(payload){
  try{
    const doc = {
      file: normalizePath(payload.file),
      start_idx: Number(payload.start_idx),
      end_idx: Number(payload.end_idx),
      text: payload.text || "",
      note: payload.note || "",
      author: payload.author || "Stacy",
      created_at: firebase.firestore.FieldValue.serverTimestamp()
    };
    const ref = await db.collection('annotations').add(doc);
    return { ok:true, id: ref.id };
  }catch(e){
    console.error('pushAnnotation error', e);
    return { ok:false, error:e };
  }
}

/* Save annotation (local optimistic + remote attempt) */
$('#cancel-annotation').addEventListener('click', ()=>{ pendingSelection = null; $('#annotation-editor').style.display='none'; $('#annotation-editor').dataset.editing=''; window.getSelection().removeAllRanges(); hideFab(); });

$('#save-annotation').addEventListener('click', async ()=>{
  if(!window.current.filePath) return alert('Open a reading first.');
  const note = $('#annotation-text').value.trim(); if(!note) return alert('Write a note.');
  const editingId = $('#annotation-editor').dataset.editing;
  const nowISO = new Date().toISOString();
  let anns = loadAnnsLocal(window.current.filePath) || [];

  if(editingId){
    const idx = anns.findIndex(a=> String(a.id) === String(editingId));
    if(idx === -1) return alert('Annotation not found.');
    anns[idx].note = note; anns[idx].edited_at = nowISO;
    saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations();
    try{ const remoteId = anns[idx]._remoteId; if(remoteId) await db.collection('annotations').doc(remoteId).update({ note, edited_at: nowISO }); }catch(e){ console.warn('remote edit failed', e); }
  } else {
    if(!pendingSelection) return alert('Select text first.');

    // If user has previously annotated the *same phrase* elsewhere, prefer to attach to the first existing occurrence
    const existing = anns.find(a => window.current.raw.slice(a.start_idx ?? a.start, a.end_idx ?? a.end) === pendingSelection.text);
    const startIdx = existing ? (existing.start_idx ?? existing.start) : Math.floor(pendingSelection.start_idx);
    const endIdx = existing ? (existing.end_idx ?? existing.end) : Math.floor(pendingSelection.end_idx);

    const newAnn = {
      id: String(Date.now()) + '-' + Math.floor(Math.random()*9999),
      file: window.current.filePath,
      start_idx: startIdx,
      end_idx: endIdx,
      text: pendingSelection.text,
      note,
      author: 'Stacy',
      created_at: nowISO
    };
    anns.push(newAnn); saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations();

    const res = await pushAnnotationToFirestore(newAnn);
    if(!res.ok){ console.warn('Firestore write failed', res.error); alert('Firestore write failed; saved locally.'); }
    else { const loc = loadAnnsLocal(window.current.filePath); const li = loc.find(a=> a.id === newAnn.id); if(li){ li._remoteId = res.id; saveAnnsLocal(window.current.filePath, loc); renderArticleWithAnnotations(); } }
  }

  $('#annotation-editor').style.display = 'none'; $('#annotation-editor').dataset.editing = ''; pendingSelection = null; window.getSelection().removeAllRanges(); hideFab();
});

/* fetch + subscribe */
async function fetchAnnotationsOnce(filePath){
  if(!filePath) return;
  try{
    const snap = await db.collection('annotations').where('file','==', normalizePath(filePath)).get();
    const anns = [];
    snap.forEach(doc => { const d = doc.data(); d._remoteId = doc.id; d.id = d.id || doc.id; anns.push(d); });
    anns.sort((a,b)=> {
      const ta = a.created_at?.toDate ? a.created_at.toDate().toISOString() : (a.created_at || a.createdAt || '');
      const tb = b.created_at?.toDate ? b.created_at.toDate().toISOString() : (b.created_at || b.createdAt || '');
      return (ta||'').localeCompare(tb||'');
    });
    saveAnnsLocal(filePath, anns);
    renderArticleWithAnnotations();
    return anns;
  }catch(e){ console.error('fetchAnnotationsOnce error', e); return null; }
}

function subscribeRealtime(filePath){
  if(unsubscribeRealtime){ try{ unsubscribeRealtime(); }catch(e){} unsubscribeRealtime = null; }
  if(pollingFallback){ clearInterval(pollingFallback); pollingFallback = null; }
  try{
    unsubscribeRealtime = db.collection('annotations').where('file','==', normalizePath(filePath)).orderBy('created_at').onSnapshot(snapshot=>{
      const anns = [];
      snapshot.forEach(doc => { const d = doc.data(); d._remoteId = doc.id; d.id = d.id || doc.id; anns.push(d); });
      anns.sort((a,b)=> {
        const ta = a.created_at?.toDate ? a.created_at.toDate().toISOString() : (a.created_at || a.createdAt || '');
        const tb = b.created_at?.toDate ? b.created_at.toDate().toISOString() : (b.created_at || b.createdAt || '');
        return (ta||'').localeCompare(tb||'');
      });
      saveAnnsLocal(filePath, anns);
      renderArticleWithAnnotations();
    }, err=>{
      console.error('onSnapshot error', err);
      if(pollingFallback) clearInterval(pollingFallback);
      pollingFallback = setInterval(()=> fetchAnnotationsOnce(filePath), 6000);
    });
  }catch(e){ console.warn('subscribeRealtime error', e); if(pollingFallback) clearInterval(pollingFallback); pollingFallback = setInterval(()=> fetchAnnotationsOnce(filePath), 6000); }
}

/* highlight click open panel */
document.addEventListener('click', (ev)=>{
  const t = ev.target;
  if(t && t.matches && t.matches('.hl')){
    const start = parseInt(t.getAttribute('data-start')), end = parseInt(t.getAttribute('data-end'));
    if(isNaN(start) || isNaN(end)) return;
    $('#right-col').classList.remove('collapsed');
    document.getElementById('right-col').scrollTop = 0;
    const anns = loadAnnsLocal(window.current.filePath) || [];
    renderAnnGroups(anns);
    setTimeout(()=>{
      const snippet = window.current.raw.slice(start, Math.min(end, start+60)).trim().slice(0,40);
      const groups = Array.from(document.querySelectorAll('#annotations-list .ann-group'));
      for(const g of groups){
        if(g.textContent && g.textContent.includes(snippet)){
          g.scrollIntoView({behavior:'smooth', block:'center'});
          g.animate([{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:500});
          break;
        }
      }
    },150);
  }
});

/* collapse buttons (now live in sidebars) */
$('#collapse-left').addEventListener('click', ()=>{ $('#left-col').classList.toggle('collapsed'); });
$('#collapse-right').addEventListener('click', ()=>{ $('#right-col').classList.toggle('collapsed'); });

/* init */
function queryParam(name){ const params = new URLSearchParams(window.location.search); return params.get(name); }

async function initApp(){
  await discoverReadings();
  const fileQuery = queryParam('file');
  if(fileQuery){
    const match = readings.find(r => normalizePath(r.path) === normalizePath(fileQuery) || r.path === fileQuery);
    if(match) { loadReading(match); return; }
    const synthetic = { path: fileQuery, title: fileQuery.split('/').pop(), download_url: `/${fileQuery}` };
    loadReading(synthetic);
    return;
  }
  if(readings.length > 0) loadReading(readings[0]);
  else { $('#article').innerHTML = '<div class="small">No readings found in /readings/. Add files or index.json.</div>'; }
}
</script>
</body>
</html>
