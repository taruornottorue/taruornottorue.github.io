<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Readings</title>

<!-- markdown renderer + firebase (compat libs kept) -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

<style>
:root{--bg:#0f0b08;--panel:#17120f;--muted:#c9b89a;--muted-2:#7b6a58;--accent:#b36b2c;--glass:rgba(255,255,255,0.02);--highlight:rgba(179,107,44,0.18);--radius:12px}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--muted);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial}
header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;border-bottom:1px solid rgba(255,255,255,0.02)}
h1{margin:0;font-size:16px}
.app{display:flex;height:calc(100vh - 64px);gap:16px;padding:16px}
.col{background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.01));border-radius:var(--radius);Padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);overflow:auto;position:relative}
.left{width:280px;flex-shrink:0}.center{flex:1;min-width:320px}.right{width:320px;flex-shrink:0}
.col.collapsed{width:44px !important;padding:6px !important;overflow:visible !important}
.col.collapsed .panel-body{display:none}
.col.collapsed .panel-header .title-wrap{display:none}
.col.collapsed .panel-header{justify-content:center}

.panel-mini{display:none;font-size:16px}
.reading-item{padding:14px;border-radius:8px;background:var(--glass);margin-bottom:8px;cursor:pointer;display:flex;align-items:center;justify-content:center}
.reading-title{font-weight:600}
.small{font-size:12px;color:var(--muted-2)}
#article{line-height:1.6;color:var(--muted);padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent);outline:none; -webkit-touch-callout:none; -webkit-user-select:text; user-select:text; -moz-user-select:text;}
.hl{background:var(--highlight);border-radius:4px;padding:0 2px;cursor:pointer}
.ann-group{margin-bottom:12px;border-radius:8px;padding:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
.ann-tabs{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px}
.ann-tab{padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);cursor:pointer;font-size:13px;color:var(--muted-2)}
.ann-active{background:linear-gradient(90deg,var(--accent), #8a5a2a);color:#fff;border:none}
.annotation-editor{margin-bottom:12px}
textarea{width:100%;min-height:88px;border-radius:8px;padding:8px;background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}
/* Annotate FAB */
#annot-fab{position:absolute;z-index:9999;display:none;padding:8px 12px;border-radius:999px;background:linear-gradient(90deg,var(--accent), #8a5a2a);color:white;border:none;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,0.5);font-weight:600}
/* Lookup button: made same look as Annotate (same size/shape/color) */
#lookup-btn{position:absolute;z-index:9999;display:none;padding:8px 12px;border-radius:999px;background:linear-gradient(90deg,var(--accent), #8a5a2a);color:white;border:none;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,0.5);font-weight:600}
.collapse-btn{background:rgba(255,255,255,0.03);color:var(--muted);border:1px solid rgba(255,255,255,0.02);padding:6px;border-radius:8px;cursor:pointer}
.collapse-icon{width:30px;height:30px;display:inline-flex;align-items:center;justify-content:center;border-radius:6px;font-weight:700;padding:0}
.panel-header { display:flex;justify-content:space-between;align-items:center;margin-bottom:8px }
.panel-header .title-wrap{display:flex;flex-direction:column}
#annotations-list .ann-group .ann-tabs{margin-bottom:6px}
#pw-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.92);z-index:100000}
#pw-box{width:420px;background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.01));padding:26px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 20px 80px rgba(0,0,0,0.8);text-align:center}
#pw-box h3{margin:0 0 8px 0;color:var(--muted);font-size:18px}
#pw-box .pw-note{color:var(--muted-2);font-size:13px;margin-bottom:12px}
#pw-box input{width:100%;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);margin-top:6px}
#pw-submit{width:180px;padding:12px;border-radius:10px;border:none;margin-top:12px;background:linear-gradient(90deg,var(--accent), #8a5a2a);color:white;font-weight:700;cursor:pointer}

/* comment UI inline inside annotation group (now part of sidebar) */
.comment-block{margin-top:8px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.02);border:1px solid rgba(255,255,255,0.02)}
.comment-item{padding:8px;border-radius:6px;margin-bottom:6px;background:rgba(0,0,0,0.03);font-size:13px}
.comment-author{display:inline-block;padding:4px 8px;border-radius:6px;background:linear-gradient(90deg,var(--accent), #8a5a2a);color:#fff;font-weight:600;margin-bottom:6px;font-size:12px}
.comment-input{display:flex;gap:8px;margin-top:8px}
.comment-input textarea{min-height:56px;flex:1;border-radius:8px;padding:8px;background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}

/* define modal */
#define-modal{display:none;position:fixed;right:18px;bottom:18px;z-index:200001;background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);max-width:420px;color:var(--muted)}
#define-modal .close-btn{margin-top:8px}

::-webkit-scrollbar{width:10px;height:10px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:linear-gradient(180deg, rgba(179,107,44,0.18), rgba(179,107,44,0.12));border-radius:10px;border:2px solid rgba(0,0,0,0)}
*{scrollbar-width:thin;scrollbar-color: rgba(179,107,44,0.18) transparent}

@media (max-width:980px){.app{flex-direction:column;height:calc(100vh - 88px);padding:10px}#annot-fab{position:fixed;right:14px;bottom:90px}#lookup-btn{position:fixed;right:14px;bottom:150px}}
</style>
</head>
<body>

<header>
  <div style="display:flex;gap:12px;align-items:center"><h1>Readings</h1><div class="small">(and also annotating if you wish to)</div></div>
  <div style="display:flex;gap:8px;align-items:center"></div>
</header>

<div class="app">
  <aside class="col left" id="left-col">
    <div class="panel-header">
      <div class="title-wrap"><div class="small">Primarily just short stories</div><strong style="font-size:15px">Readings</strong></div>
      <button class="collapse-btn collapse-icon" id="collapse-left" title="Toggle left">O</button>
    </div>

    <div class="panel-body">
      <div id="reading-list"><div class="small">Loading…</div></div>
      <hr style="border:none;height:1px;background:rgba(255,255,255,0.02);margin:12px 0" />
      <div id="index-json-path" style="display:none;margin-top:6px;color:var(--muted-2)"></div>
      <div id="debug-block" style="display:none"></div>
    </div>
  </aside>

  <main class="col center">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
      <div><h2 id="post-title" style="margin:4px 0 0 0">Nothing loaded</h2></div>
      <div style="text-align:right"><div id="current-file" class="small" style="display:none">—</div></div>
    </div>
    <div id="article" tabindex="0" aria-label="Article content"><div class="small">Open a reading from the left.</div></div>
  </main>

  <aside class="col right" id="right-col">
    <div class="panel-header">
      <div class="title-wrap"><strong style="font-size:15px">Annotations</strong></div>
      <button class="collapse-btn collapse-icon" id="collapse-right" title="Toggle right">X</button>
    </div>

    <div class="panel-body">
      <div id="annotation-editor" class="annotation-editor" style="display:none">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Add annotation</strong></div>
          <div class="small" id="selection-preview"></div>
        </div>
        <textarea id="annotation-text" placeholder="write your note"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button class="collapse-btn" id="save-annotation">Save</button>
          <button class="collapse-btn" id="cancel-annotation">Cancel</button>
          <button class="collapse-btn" id="delete-annotation" style="display:none;background:rgba(255,64,64,0.06);color:var(--muted)">Delete</button>
        </div>
        <div class="small" style="margin-top:8px;color:var(--muted-2)">This will get saved for anyone else to see. You can edit or delete it later.</div>
      </div>

      <div id="annotations-list"><div class="small">Select text to create an annotation.</div></div>
    </div>
  </aside>
</div>

<button id="annot-fab" aria-label="Annotate">Annotate</button>
<button id="lookup-btn" aria-label="Look up">Look up</button>

<div id="pw-overlay">
  <div id="pw-box">
    <h3>Password</h3>
    <div class="pw-note">I don't know why I added this</div>
    <input id="pw-input" placeholder="Password" autocomplete="off"/>
    <div style="display:flex;justify-content:center">
      <button id="pw-submit">Unlock</button>
    </div>
  </div>
</div>

<!-- define modal (opaque background, not translucent) -->
<div id="define-modal">
  <div id="define-content"></div>
  <div style="text-align:right"><button class="collapse-btn close-btn" id="close-define">Close</button></div>
</div>

<script>
/*
  Preservation of comment drafts fix:
  - commentDrafts stored per file and remoteId (localStorage + in-memory)
  - on textarea input save draft
  - before re-render capture focused comment textarea + selection, after re-render restore value, focus, selection
  - when comment posted, clear the draft
*/

const PASSWORD = "Stacy"; // change this
const READINGS_PATH = "readings";   // change if different
/* Paste your Firebase web config here */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyCxhiw5V3epzzWeFxlMGQ8SH4QjWDjH_1A",
  authDomain: "taruornottorue.firebaseapp.com",
  projectId: "taruornottorue",
  // OPTIONAL: storageBucket, messagingSenderId, appId...
  storageBucket: "taruornottorue.firebasestorage.app",
  messagingSenderId: "458061841918",
  appId: "1:458061841918:web:1cc68c086bcbf81ee3acaf"
};




firebase.initializeApp(FIREBASE_CONFIG);
const db = firebase.firestore();

/* DOM helpers */
const $ = s => document.querySelector(s);
const el = (t,a={},h='') => { const e = document.createElement(t); Object.assign(e,a); if(h) e.innerHTML = h; return e; };
function escapeHtml(s){ return (s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;'); }
function normalizeForMatching(s){
  if(s === undefined || s === null) return '';
  return String(s)
    .replace(/\r\n/g,'\n').replace(/\r/g,'\n')
    .replace(/\u2018|\u2019/g,"'")
    .replace(/\u201C|\u201D/g,'"')
    .replace(/\u00A0/g,' ')
    .replace(/\s+/g,' ');
}

/* app state */
window.current = window.current || { filePath: null, raw: null, title: null };
let readings = [];
let pendingSelection = null;
let unsubscribeRealtime = null;
let pollingFallback = null;
window.current.displayToRawMap = []; // map display index -> raw index
window.current.displayText = '';     // the flattened display text (raw without newline chars)

// open comment group remote id or annotation id
let openCommentFor = null;

// comment drafts map: { "<file>::<remoteId>": { value, selStart, selEnd } }
// also persisted to localStorage for resilience
const DRAFT_PREFIX = 'candle_comment_draft::';
const commentDrafts = {}; // in-memory cache

function draftKey(remoteId){
  const fp = window.current.filePath || 'unknown';
  return `${DRAFT_PREFIX}${fp}::${remoteId}`;
}

function saveDraftToStorage(remoteId, value, selStart, selEnd){
  try{
    const key = draftKey(remoteId);
    const payload = { value: value || '', selStart: selStart ?? null, selEnd: selEnd ?? null, updated: Date.now() };
    localStorage.setItem(key, JSON.stringify(payload));
    commentDrafts[key] = payload;
  }catch(e){ console.warn('saveDraftToStorage failed', e); }
}

function loadDraftFromStorage(remoteId){
  try{
    const key = draftKey(remoteId);
    if(commentDrafts[key]) return commentDrafts[key];
    const raw = localStorage.getItem(key);
    if(!raw) return { value: '', selStart: null, selEnd: null };
    const parsed = JSON.parse(raw);
    commentDrafts[key] = parsed;
    return parsed;
  }catch(e){ console.warn('loadDraftFromStorage failed', e); return { value: '', selStart: null, selEnd: null }; }
}

function clearDraft(remoteId){
  try{
    const key = draftKey(remoteId);
    localStorage.removeItem(key);
    delete commentDrafts[key];
  }catch(e){ console.warn('clearDraft failed', e); }
}

/* password overlay */
function isUnlocked(){ try{ return sessionStorage.getItem('candle_unlocked') === '1'; }catch(e){return false;} }
function setUnlocked(){ try{ sessionStorage.setItem('candle_unlocked','1'); }catch(e){} }
function showOverlay(){ $('#pw-overlay').style.display='flex'; document.body.style.overflow='hidden'; $('#pw-input').focus(); }
function hideOverlay(){ $('#pw-overlay').style.display='none'; document.body.style.overflow=''; }

if(!isUnlocked()) showOverlay(); else initApp();
$('#pw-submit').addEventListener('click', ()=>{ if($('#pw-input').value === PASSWORD){ setUnlocked(); hideOverlay(); initApp(); } else alert('Wrong password'); });
$('#pw-input').addEventListener('keydown', (e)=>{ if(e.key === 'Enter') $('#pw-submit').click(); });

function normalizePath(p){ if(!p) return p; return p.startsWith('/') ? p.slice(1) : p; }

/* Readings discovery/render */
async function discoverReadings(){
  const indexPath = `/${READINGS_PATH}/index.json`;
  try{
    const r = await fetch(indexPath, {cache:'no-store'});
    if(r.ok){
      const arr = await r.json();
      readings = arr.map(item => {
        if(typeof item === 'string') return { path: item, title: item.split('/').pop() };
        return { path: item.path, title: item.title || item.path.split('/').pop(), download_url: item.download_url };
      });
      renderReadingList();
      return;
    }
  }catch(e){ console.warn('discoverReadings error', e); }
  $('#reading-list').innerHTML = '<div class="small">No readings found. Add /readings/index.json</div>';
}

function renderReadingList(){
  const cont = $('#reading-list'); cont.innerHTML = '';
  readings.forEach(r=>{
    const item = el('div',{className:'reading-item'});
    item.innerHTML = `<div style="text-align:center;width:100%"><div class="reading-title">${escapeHtml(r.title)}</div></div>`;
    item.addEventListener('click', ()=> loadReading(r));
    cont.appendChild(item);
  });
}

/* Build display mapping: create displayText (raw without newline chars) and a map displayIndex->rawIndex */
function buildDisplayMapping(raw){
  const map = [];
  let display = '';
  for(let i=0;i<raw.length;i++){
    const ch = raw[i];
    if(ch === '\n') continue; // we remove newlines from display text because in DOM we use <br> or paragraphs
    map.push(i);
    display += ch;
  }
  return { displayText: display, displayToRawMap: map };
}

/* build annotated HTML (uses raw indices for spans) */
function buildAnnotatedHtml(text, anns){
  // sanitize and ensure numeric start/end
  anns = (anns || []).slice().map(a => {
    const s = Number(a.start_idx ?? a.start);
    const e = Number(a.end_idx ?? a.end);
    return Object.assign({}, a, { start_idx: s, end_idx: e });
  }).filter(a => !isNaN(a.start_idx) && !isNaN(a.end_idx) && a.end_idx > a.start_idx)
    .sort((a,b)=> a.start_idx - b.start_idx);

  // dedupe exact same start/end (keep first)
  const seen = new Set();
  const filtered = [];
  for(const a of anns){
    const key = `${a.start_idx}:${a.end_idx}`;
    if(seen.has(key)) continue;
    seen.add(key);
    filtered.push(a);
  }

  // groups by identical start/end so that multiple notes on same span are grouped
  const groups = [];
  for(const a of filtered){
    const start = a.start_idx;
    const end = a.end_idx;
    const last = groups.length ? groups[groups.length-1] : null;
    if(last && last.start === start && last.end === end) last.items.push(a);
    else groups.push({ start, end, items: [a] });
  }

  // Build output by iterating raw string slices and injecting spans at start/end
  let out = '', cursor = 0;
  for(const g of groups){
    if(g.start > cursor) out += escapeHtml(text.slice(cursor, g.start));
    const excerpt = escapeHtml(text.slice(g.start, g.end));
    const ids = g.items.map(i=>i.id).join(',');
    out += `<span class="hl" tabindex="0" data-ann-ids="${ids}" data-start="${g.start}" data-end="${g.end}">${excerpt}</span>`;
    cursor = g.end;
  }
  if(cursor < text.length) out += escapeHtml(text.slice(cursor));

  // Convert newlines in the resulting escaped text to paragraphs/line breaks
  out = out.replace(/\n{2,}/g, '</p><p>').replace(/\n/g, '<br>');
  return `<p>${out}</p>`;
}

/* Before re-render helpers: capture active comment state so we can restore after re-render */
function captureActiveCommentState(){
  try{
    const active = document.activeElement;
    if(!active) return null;
    // pattern: id="comment-input-<remoteId>"
    const m = active.id ? active.id.match(/^comment-input-(.+)$/) : null;
    if(!m) return null;
    const remoteId = m[1];
    return {
      remoteId,
      selStart: active.selectionStart ?? null,
      selEnd: active.selectionEnd ?? null,
      scrollTop: active.scrollTop ?? 0
    };
  }catch(e){
    return null;
  }
}

function restoreActiveCommentState(state){
  if(!state) return;
  const id = `comment-input-${state.remoteId}`;
  const ta = document.getElementById(id);
  if(!ta) return;
  // restore value from draft (ensures value is up-to-date), then restore selection & focus
  const d = loadDraftFromStorage(state.remoteId);
  if(d && typeof d.value === 'string'){
    ta.value = d.value;
  }
  ta.focus();
  try{
    if(state.selStart !== null && state.selEnd !== null) ta.setSelectionRange(state.selStart, state.selEnd);
  }catch(e){}
  ta.scrollTop = state.scrollTop ?? 0;
}

/* render article and compute display->raw mapping for later accurate conversions
   now captures active comment state before re-render and restores afterwards */
function renderArticleWithAnnotations(){
  const preState = captureActiveCommentState();
  const raw = window.current.raw || '';
  // build display mapping first and store it on window.current
  const mapping = buildDisplayMapping(raw);
  window.current.displayText = mapping.displayText;
  window.current.displayToRawMap = mapping.displayToRawMap;

  const anns = loadAnnsLocal(window.current.filePath) || [];
  $('#article').innerHTML = buildAnnotatedHtml(raw, anns);

  // now render annotation groups and then restore active comment focus/selection
  renderAnnGroups(anns);
  // small timeout to allow DOM to settle
  setTimeout(()=>{ restoreActiveCommentState(preState); }, 40);
}

/* local storage helpers */
const STORAGE_PREFIX = 'candle_annot_';
function annKeyFor(fp){ return STORAGE_PREFIX + 'anns::' + fp; }
function loadAnnsLocal(fp){ try{ const s = localStorage.getItem(annKeyFor(fp)); return s ? JSON.parse(s) : []; }catch(e){ return []; } }
function saveAnnsLocal(fp, arr){ localStorage.setItem(annKeyFor(fp), JSON.stringify(arr)); }

/* parse Taru prefix for notes and comments */
function parseTaruPrefix(raw){
  if(!raw) return { text: raw, author: undefined };
  const m = raw.match(/^\s*(Taru)\s+(.*)$/i);
  if(m) return { text: m[2].trim(), author: m[1] };
  return { text: raw, author: undefined };
}

/* render annotation groups - now includes inline comment area.
   Wiring for comment inputs includes saving drafts on input and preserving drafts on re-render. */
function renderAnnGroups(anns){
  const cont = $('#annotations-list'); cont.innerHTML = '';
  if(!anns || anns.length===0){ cont.innerHTML = '<div class="small">No annotations yet.</div>'; return; }
  anns = anns.slice().map(a => ({ ...a, start_idx: Number(a.start_idx ?? a.start), end_idx: Number(a.end_idx ?? a.end) }))
        .filter(a => !isNaN(a.start_idx) && !isNaN(a.end_idx) && a.end_idx > a.start_idx)
        .sort((a,b)=> a.start_idx - b.start_idx);

  // group
  const groups = [];
  for(const a of anns){
    const start = a.start_idx;
    const end = a.end_idx;
    const last = groups.length ? groups[groups.length-1] : null;
    if(last && last.start === start && last.end === end) last.items.push(a);
    else groups.push({ start, end, items: [a] });
  }

  groups.forEach(g=>{
    const excerpt = window.current.raw.slice(g.start, g.end);
    const groupEl = el('div',{className:'ann-group'});

    groupEl.appendChild(el('div',{}, `<div class="small" style="margin-bottom:8px"><em>Excerpt:</em> "${escapeHtml(excerpt.slice(0,200))}${excerpt.length>200?'…':''}"</div>`));

    const tabs = el('div',{className:'ann-tabs'});
    const body = el('div',{}, `${marked.parseInline(g.items[0].note||'')}<div style="margin-top:8px;display:flex;gap:8px">
      <button class="collapse-btn" data-id="${g.items[0].id}" data-action="jump">Jump</button>
      <button class="collapse-btn" data-id="${g.items[0].id}" data-action="edit">Edit</button>
      <button class="collapse-btn" data-id="${g.items[0]._remoteId||g.items[0].id}" data-action="comment">Comment</button>
      <button class="collapse-btn" data-id="${g.items[0].id}" data-action="delete">Delete</button>
      </div>`);
    g.items.forEach((it, idx)=>{
      const authorLabel = escapeHtml(it.author || 'Stacy');
      const tab = el('button',{className:'ann-tab'}, authorLabel);
      if(idx===0) tab.classList.add('ann-active');
      tab.addEventListener('click', ()=> {
        tabs.querySelectorAll('.ann-tab').forEach(t=>t.classList.remove('ann-active'));
        tab.classList.add('ann-active');
        body.innerHTML = `${marked.parseInline(it.note||'')}<div style="margin-top:8px;display:flex;gap:8px">
          <button class="collapse-btn" data-id="${it.id}" data-action="jump">Jump</button>
          <button class="collapse-btn" data-id="${it.id}" data-action="edit">Edit</button>
          <button class="collapse-btn" data-id="${it._remoteId||it.id}" data-action="comment">Comment</button>
          <button class="collapse-btn" data-id="${it.id}" data-action="delete">Delete</button>
          </div>`;
      });
      tabs.appendChild(tab);
    });
    groupEl.appendChild(tabs);
    groupEl.appendChild(body);

    // Inline comment area (initially hidden unless openCommentFor matches)
    const remoteId = g.items[0]._remoteId || g.items[0].id;
    const commentBlock = el('div',{className:'comment-block', id:`comments-for-${remoteId}`, style: openCommentFor === remoteId ? '' : 'display:none'});
    // label showing which annotation it's for
    commentBlock.appendChild(el('div',{className:'small', style:'margin-bottom:8px;font-weight:600'}, `Commenting on: "${escapeHtml(excerpt.slice(0,120))}${excerpt.length>120?'…':''}"`));
    // comments list container
    const commentsList = el('div',{className:'comments-list', id:`comments-list-${remoteId}`}, `<div class="small">Loading comments…</div>`);
    commentBlock.appendChild(commentsList);
    // input row
    const inputRow = el('div',{className:'comment-input'});
    const textarea = el('textarea',{id:`comment-input-${remoteId}`, placeholder:'Write a comment...'});
    // load draft if present
    try{
      const d = loadDraftFromStorage(remoteId);
      if(d && typeof d.value === 'string' && d.value.length) textarea.value = d.value;
      // restore selection if available slightly later (done by restoreActiveCommentState)
    }catch(e){}
    inputRow.appendChild(textarea);
    const postBtn = el('button',{className:'collapse-btn', id:`post-comment-${remoteId}`, 'data-remote-id': remoteId}, 'Post');
    inputRow.appendChild(postBtn);
    commentBlock.appendChild(inputRow);

    groupEl.appendChild(commentBlock);

    cont.appendChild(groupEl);
  });

  // wire up action buttons in groups
  cont.querySelectorAll('[data-action]').forEach(btn=>{
    btn.addEventListener('click', async (ev)=>{
      const id = btn.getAttribute('data-id'), action = btn.getAttribute('data-action');
      const anns = loadAnnsLocal(window.current.filePath) || [];
      const ann = anns.find(a=> String(a.id) === String(id)) || anns.find(a => String(a._remoteId) === String(id));
      if(action === 'jump'){
        if(!ann) return alert('Not found');
        const sp = document.querySelector(`[data-ann-ids*="${ann.id}"]`) || document.querySelector(`[data-start="${ann.start_idx}"]`);
        if(sp){ sp.scrollIntoView({behavior:'smooth', block:'center'}); sp.animate([{boxShadow:'0 0 0 rgba(0,0,0,0)'},{boxShadow:'0 10px 40px rgba(179,107,44,0.22)'}],{duration:900}); }
      } else if(action === 'edit'){
        if(!ann) return alert('Not found');
        pendingSelection = { start_idx: Number(ann.start_idx), end_idx: Number(ann.end_idx), text: window.current.raw.slice(Number(ann.start_idx), Number(ann.end_idx)) };
        $('#selection-preview').innerText = `"${pendingSelection.text.slice(0,90)}${pendingSelection.text.length>90?'…':''}"`;
        $('#annotation-text').value = ann.note || '';
        $('#annotation-editor').style.display = 'block';
        $('#annotation-editor').dataset.editing = ann.id;
        $('#delete-annotation').style.display = 'inline-block';
        $('#delete-annotation').dataset.remoteId = ann._remoteId || '';
        document.getElementById('right-col').classList.remove('collapsed');
      } else if(action === 'comment'){
        const remoteId = id; // ensure this is remote id or fall back to id
        const targetAnn = anns.find(a => (a._remoteId && String(a._remoteId) === String(remoteId)) || String(a.id) === String(remoteId));
        if(targetAnn && !targetAnn._remoteId) return alert('This annotation has not been saved remotely yet. Save first to enable comments.');
        // set as open comment group, re-render to make comment block visible and then fetch comments
        openCommentFor = remoteId;
        renderAnnGroups(anns);
        fetchAndRenderCommentsFor(remoteId);
        setTimeout(()=>{ const t = document.getElementById(`comment-input-${remoteId}`); if(t) t.focus(); }, 120);
      } else if(action === 'delete'){
        if(!ann) return alert('Not found');
        if(!confirm('Delete this annotation?')) return;
        const idx = anns.findIndex(a => String(a.id) === String(ann.id));
        if(idx !== -1){ anns.splice(idx,1); saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations(); }
        try{ if(ann._remoteId) await deleteAnnotationRemote(ann._remoteId); }catch(e){ console.warn('remote delete failed', e); alert('Remote delete failed'); }
      }
    });
  });

  // wire post comment buttons & input handlers
  cont.querySelectorAll('[id^="post-comment-"]').forEach(btn=>{
    const remoteId = btn.getAttribute('data-remote-id') || btn.id.replace('post-comment-','');
    const textarea = document.getElementById(`comment-input-${remoteId}`);
    const list = document.getElementById(`comments-list-${remoteId}`);
    // ensure event registration: remove existing listeners if any by cloning
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    newBtn.addEventListener('click', async (ev)=>{
      const ta = document.getElementById(`comment-input-${remoteId}`);
      if(!ta) return alert('Comment input not found.');
      const raw = ta.value.trim();
      if(!raw) return alert('Write something');
      const parsed = parseTaruPrefix(raw);
      const finalText = parsed.text;
      const finalAuthor = parsed.author || 'Stacy';
      try{
        await db.collection('annotations').doc(remoteId).collection('comments').add({ text: finalText, author: finalAuthor, created_at: firebase.firestore.FieldValue.serverTimestamp() });
        // append locally in UI (no date/time)
        const listEl = document.getElementById(`comments-list-${remoteId}`);
        if(listEl){
          if(listEl.querySelector('.small')) listEl.innerHTML = '';
          const item = el('div',{className:'comment-item'}, `<div class="comment-author">${escapeHtml(finalAuthor)}</div><div style="margin-top:6px">${escapeHtml(finalText)}</div>`);
          listEl.appendChild(item);
        }
        ta.value = '';
        clearDraft(remoteId);
      }catch(e){
        console.error('post comment failed', e);
        alert('Comment failed');
      }
    });

    // save drafts on input events
    if(textarea){
      // remove any existing handler by cloning and replacing (to avoid duplication)
      const taClone = textarea.cloneNode(true);
      textarea.parentNode.replaceChild(taClone, textarea);
      taClone.addEventListener('input', (ev)=>{
        const v = taClone.value;
        const selStart = taClone.selectionStart ?? null;
        const selEnd = taClone.selectionEnd ?? null;
        saveDraftToStorage(remoteId, v, selStart, selEnd);
      });
      // also save caret position on keyup (for some browsers)
      taClone.addEventListener('keyup', (ev)=>{
        const v = taClone.value;
        const selStart = taClone.selectionStart ?? null;
        const selEnd = taClone.selectionEnd ?? null;
        saveDraftToStorage(remoteId, v, selStart, selEnd);
      });
    }
  });

  // after wiring, ensure comments loaded for openCommentFor
  if(openCommentFor){
    fetchAndRenderCommentsFor(openCommentFor);
  }
}

/* fetch comments for annotation (remoteId) and render into the inline list (no date/time) */
async function fetchAndRenderCommentsFor(remoteId){
  if(!remoteId) return;
  const listId = `comments-list-${remoteId}`;
  const listEl = document.getElementById(listId);
  if(!listEl) return;
  listEl.innerHTML = '<div class="small">Loading comments…</div>';
  try{
    const snap = await db.collection('annotations').doc(remoteId).collection('comments').orderBy('created_at','asc').get();
    const comments = [];
    snap.forEach(d => { comments.push({ id:d.id, ...d.data() }); });
    if(comments.length === 0) listEl.innerHTML = '<div class="small">No comments yet.</div>';
    else {
      listEl.innerHTML = '';
      for(const c of comments){
        const author = c.author || 'Anonymous';
        const text = c.text || '';
        const item = el('div',{className:'comment-item'}, `<div class="comment-author">${escapeHtml(author)}</div><div style="margin-top:6px">${escapeHtml(text)}</div>`);
        listEl.appendChild(item);
      }
    }
  }catch(e){
    console.error('fetch comments error', e);
    listEl.innerHTML = '<div class="small">Could not load comments.</div>';
  }
}

/* Firestore helpers */
async function pushAnnotationToFirestore(payload){
  try{
    const doc = {
      file: normalizePath(payload.file),
      start_idx: Number(payload.start_idx),
      end_idx: Number(payload.end_idx),
      text: payload.text || "",
      note: payload.note || "",
      author: payload.author || "Stacy",
      created_at: firebase.firestore.FieldValue.serverTimestamp()
    };
    const ref = await db.collection('annotations').add(doc);
    return { ok:true, id: ref.id };
  }catch(e){
    console.error('pushAnnotation error', e);
    return { ok:false, error:e };
  }
}

async function updateAnnotationRemote(remoteId, updateObj){
  try{
    await db.collection('annotations').doc(remoteId).update(updateObj);
    return { ok:true };
  }catch(e){ console.warn('updateAnnotationRemote failed', e); return { ok:false, error:e }; }
}

async function deleteAnnotationRemote(remoteId){
  try{ await db.collection('annotations').doc(remoteId).delete(); return { ok:true }; }
  catch(e){ console.warn('deleteAnnotationRemote failed', e); return { ok:false, error:e }; }
}

/* selection -> display offset mapping helpers (kept robust) */

function collectTextNodes(root){
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
  const arr = [];
  let n;
  while(n = walker.nextNode()){
    arr.push(n);
  }
  return arr;
}

/* convert DOM Range start to display char offset robustly using Range text length from container start */
function displayOffsetFromRange(range){
  try{
    if(!range) return null;
    const container = document.getElementById('article');
    if(!container.contains(range.startContainer)) return null;
    const r = document.createRange();
    r.setStart(container, 0);
    try {
      r.setEnd(range.startContainer, range.startOffset);
    } catch(e){
      const nodes = collectTextNodes(container);
      let chars = 0;
      for(const node of nodes){
        if(node === range.startContainer){
          return chars + range.startOffset;
        }
        chars += node.textContent.length;
      }
      return null;
    }
    return r.toString().length;
  }catch(e){
    console.warn('displayOffsetFromRange error', e);
    return null;
  }
}

/* convert display offset/length to raw start/end using mapping computed earlier */
function displayToRawRange(displayStart, length){
  const map = window.current.displayToRawMap || [];
  const displayText = window.current.displayText || '';
  if(displayStart === null || displayStart === undefined) return null;
  const start = Math.max(0, Math.min(displayText.length, displayStart));
  const lastIndexUnclamped = displayStart + Math.max(0, length) - 1;
  const lastIndex = Math.max(0, Math.min(displayText.length - 1, lastIndexUnclamped));
  let rawStart = map[start];
  if(rawStart === undefined){
    let found = false;
    for(let i = start+1; i < Math.min(map.length, start + 8); i++){
      if(map[i] !== undefined){ rawStart = map[i]; found = true; break; }
    }
    if(!found){
      for(let i = start-1; i >= Math.max(0, start-8); i--){
        if(map[i] !== undefined){ rawStart = map[i]; break; }
      }
    }
  }
  const rawEndBase = map[lastIndex];
  let rawEnd;
  if(rawEndBase !== undefined) rawEnd = rawEndBase + 1;
  else if(rawStart !== undefined) rawEnd = rawStart + length;
  else rawEnd = undefined;

  if(rawStart === undefined || rawEnd === undefined || rawEnd <= rawStart) return null;
  return { start_idx: rawStart, end_idx: rawEnd };
}

/* fallback: find indices in displayText (normalized) */
function findAllIndicesInDisplay(display, needle){
  const res = [];
  if(!needle) return res;
  let pos = 0;
  while(true){
    const idx = display.indexOf(needle, pos);
    if(idx === -1) break;
    res.push(idx);
    pos = idx + Math.max(1, needle.length);
  }
  return res;
}

/* DOM range from display char index */
function domRangeForDisplayIndex(container, displayIndex, length){
  const nodes = collectTextNodes(container);
  let chars = 0;
  const range = document.createRange();
  for(const node of nodes){
    const next = chars + node.textContent.length;
    if(displayIndex < next){
      const startOffset = Math.max(0, displayIndex - chars);
      range.setStart(node, startOffset);
      if(length <= node.textContent.length - startOffset){
        range.setEnd(node, startOffset + length);
        return range;
      }
      let remaining = length - (node.textContent.length - startOffset);
      let reachedStartNode = false;
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
      let n;
      while((n = walker.nextNode())){
        if(!reachedStartNode){
          if(n === node) reachedStartNode = true;
          continue;
        }
        if(remaining <= n.textContent.length){ range.setEnd(n, remaining); return range; }
        remaining -= n.textContent.length;
      }
      range.setEnd(node, node.textContent.length);
      return range;
    }
    chars = next;
  }
  return null;
}

/* compute selection robustly: uses display mapping first, fallback to text search+rect distance */
const articleEl = document.getElementById('article');
const annotFab = document.getElementById('annot-fab');
const lookupBtn = document.getElementById('lookup-btn');

function hideFabAndLookup(){ annotFab.style.display='none'; lookupBtn.style.display='none'; }

/* position helpers */
function showFabAtRect(rect){
  if(!rect) return hideFabAndLookup();
  const scrollY = window.scrollY || window.pageYOffset;
  const left = Math.max(8, rect.left + (rect.width/2) - 40);
  const top = rect.top + scrollY - 44;
  annotFab.style.left = left + 'px';
  annotFab.style.top = top + 'px';
  annotFab.style.display = 'block';
  // lookup button slightly above
  lookupBtn.style.left = (left + 96) + 'px';
  lookupBtn.style.top = (top) + 'px';
  lookupBtn.style.display = 'block';
}

/* capture selection into pendingSelection using mapping */
function captureSelectionFromRange(range){
  const selText = range.toString();
  if(!selText || !window.current.raw) return null;

  const displayStart = displayOffsetFromRange(range);
  if(displayStart !== null && displayStart !== undefined){
    const dr = displayToRawRange(displayStart, selText.length);
    if(dr){
      pendingSelection = { start_idx: dr.start_idx, end_idx: dr.end_idx, text: window.current.raw.slice(dr.start_idx, dr.end_idx) };
      return pendingSelection;
    }
  }

  const displayText = normalizeForMatching(window.current.displayText || '');
  const needle = normalizeForMatching(selText);
  const indices = findAllIndicesInDisplay(displayText, needle);
  if(indices.length === 0) { pendingSelection = null; return null; }
  const selRect = range.getBoundingClientRect();
  let best = null; let bestDist = Infinity;
  for(const idx of indices){
    const drange = domRangeForDisplayIndex(articleEl, idx, selText.length);
    if(!drange) continue;
    const r = drange.getBoundingClientRect();
    if(!r || (r.width===0 && r.height===0)) continue;
    const d = rectDistance(selRect, r);
    if(d < bestDist){ bestDist = d; best = { idx, range: drange, rect: r }; }
  }
  if(!best){ pendingSelection = null; return null; }
  const rawRange = displayToRawRange(best.idx, selText.length);
  if(!rawRange){ pendingSelection = null; return null; }
  pendingSelection = { start_idx: rawRange.start_idx, end_idx: rawRange.end_idx, text: window.current.raw.slice(rawRange.start_idx, rawRange.end_idx) };
  return pendingSelection;
}

/* rect distance */
function rectDistance(a,b){ const ax=a.left+a.width/2, ay=a.top+a.height/2, bx=b.left+b.width/2, by=b.top+b.height/2; return Math.hypot(ax-bx, ay-by); }

/* selectionchange logic */
document.addEventListener('selectionchange', onSelectionChange);
document.addEventListener('pointerup', onSelectionChange);

function onSelectionChange(){
  const sel = window.getSelection();
  const editorOpen = document.getElementById('annotation-editor').style.display === 'block';
  if(!sel || sel.rangeCount === 0){ if(editorOpen) return; pendingSelection = null; hideFabAndLookup(); return; }
  const range = sel.getRangeAt(0);
  const text = sel.toString();
  if(!text || !window.current.raw){ if(editorOpen) return; pendingSelection = null; hideFabAndLookup(); return; }

  // try to capture selection
  const cap = captureSelectionFromRange(range);
  if(!cap){ if(editorOpen) return; pendingSelection = null; hideFabAndLookup(); return; }

  // compute rect for placement
  const selRect = range.getBoundingClientRect();
  if(selRect && selRect.width>0 && selRect.height>0){
    if(window.innerWidth < 980){ annotFab.style.position='fixed'; lookupBtn.style.position='fixed'; annotateFabFixedPlacement(); }
    else { annotFab.style.position='absolute'; lookupBtn.style.position='absolute'; showFabAtRect(selRect); }
  } else {
    annotFab.style.position='fixed'; lookupBtn.style.position='fixed';
    annotateFabFixedPlacement();
  }

  // Only show lookup button for single-token selections (no whitespace)
  if(/^\S+$/.test(text.trim())) lookupBtn.style.display = 'block';
  else lookupBtn.style.display = 'none';
}

function annotateFabFixedPlacement(){
  annotFab.style.right = '14px'; annotFab.style.bottom = '110px'; annotFab.style.left = ''; annotFab.style.top = ''; annotFab.style.display='block';
  lookupBtn.style.right = '14px'; lookupBtn.style.bottom = '150px'; lookupBtn.style.left = ''; lookupBtn.style.top = ''; // slightly above
  lookupBtn.style.display = 'none'; // become visible if single-token
}

/* prevent selection loss on FAB click - capture selection on mousedown */
annotFab.addEventListener('pointerdown', (ev)=>{
  ev.preventDefault(); // prevents selection collapse
  const sel = window.getSelection();
  if(!sel || sel.rangeCount===0) return;
  const range = sel.getRangeAt(0);
  captureSelectionFromRange(range);
});

/* when annotate clicked, open editor. The pointerdown has already captured selection. */
annotFab.addEventListener('click', ()=>{
  if(!pendingSelection) return alert('No selection.');
  $('#selection-preview').innerText = `"${pendingSelection.text.slice(0,120)}${pendingSelection.text.length>120?'…':''}"`;
  $('#annotation-text').value = '';
  $('#annotation-editor').style.display = 'block';
  $('#annotation-editor').dataset.editing = '';
  $('#delete-annotation').style.display = 'none';
  $('#annotation-editor').dataset.remoteId = '';
  document.getElementById('right-col').classList.remove('collapsed');
  document.getElementById('right-col').scrollTop = 0;
  hideFabAndLookup();
});

/* lookup button handlers: pointerdown prevents selection loss too */
lookupBtn.addEventListener('pointerdown', (ev)=>{ ev.preventDefault(); });
lookupBtn.addEventListener('click', ()=>{
  const sel = window.getSelection(); if(!sel || sel.rangeCount===0) return;
  const text = sel.toString().trim();
  if(!text) return alert('No selection.');
  lookupDefinition(text);
  hideFabAndLookup();
});

/* dictionary lookup (unchanged) */
async function lookupDefinition(word){
  $('#define-content').innerHTML = '<div class="small">Looking up…</div>';
  $('#define-modal').style.display = 'block';
  try{
    const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word)}`);
    if(!res.ok) throw new Error('Not found');
    const data = await res.json();
    const entry = data[0] || {};
    const meanings = entry.meanings || [];
    let html = `<div style="font-weight:700">${escapeHtml(entry.word||word)} ${entry.phonetics && entry.phonetics[0] ? '('+escapeHtml(entry.phonetics[0].text)+')' : ''}</div>`;
    if(meanings.length>0){
      const m = meanings[0];
      html += `<div style="margin-top:6px;font-size:13px">${escapeHtml(m.partOfSpeech||'')}</div>`;
      const defs = m.definitions || [];
      if(defs.length>0){
        html += `<div style="margin-top:6px">${escapeHtml(defs[0].definition||'')}</div>`;
        if(defs[0].example) html += `<div class="small" style="margin-top:6px;color:var(--muted-2)">Example: ${escapeHtml(defs[0].example)}</div>`;
      }
    } else {
      html += `<div class="small">No meaning found.</div>`;
    }
    $('#define-content').innerHTML = html;
  }catch(e){
    $('#define-content').innerHTML = `<div class="small">No definition found for "${escapeHtml(word)}".</div>`;
  }
}
$('#close-define').addEventListener('click', ()=>{ $('#define-modal').style.display='none'; });

/* Save & edit annotations (unchanged except Taru parse already in place) */
$('#cancel-annotation').addEventListener('click', ()=>{ pendingSelection = null; $('#annotation-editor').style.display='none'; $('#annotation-editor').dataset.editing=''; $('#annotation-editor').dataset.remoteId=''; window.getSelection().removeAllRanges(); hideFabAndLookup(); });

$('#delete-annotation').addEventListener('click', async ()=>{
  const editingId = $('#annotation-editor').dataset.editing;
  if(!editingId) return alert('No annotation selected for deletion');
  if(!confirm('Delete this annotation?')) return;
  let anns = loadAnnsLocal(window.current.filePath) || [];
  const idx = anns.findIndex(a=> String(a.id) === String(editingId));
  const ann = anns[idx];
  if(idx !== -1){ anns.splice(idx,1); saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations(); }
  $('#annotation-editor').style.display='none'; $('#annotation-editor').dataset.editing=''; $('#annotation-editor').dataset.remoteId='';
  try{ if(ann && ann._remoteId) await deleteAnnotationRemote(ann._remoteId); }catch(e){ console.warn('remote delete failed', e); alert('Remote delete failed'); }
});

$('#save-annotation').addEventListener('click', async ()=>{
  if(!window.current.filePath) return alert('Open a reading first.');
  let noteRaw = $('#annotation-text').value.trim(); if(!noteRaw) return alert('Write a note.');
  const editingId = $('#annotation-editor').dataset.editing;
  const nowISO = new Date().toISOString();
  let anns = loadAnnsLocal(window.current.filePath) || [];

  const parsed = parseTaruPrefix(noteRaw);
  const finalNote = parsed.text;
  const finalAuthor = parsed.author;

  if(editingId){
    const idx = anns.findIndex(a=> String(a.id) === String(editingId));
    if(idx === -1) return alert('Annotation not found.');
    anns[idx].note = finalNote;
    if(finalAuthor) anns[idx].author = finalAuthor;
    anns[idx].edited_at = nowISO;
    saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations();

    try{
      const remoteId = anns[idx]._remoteId;
      if(remoteId){
        const updateObj = { note: finalNote, edited_at: nowISO };
        if(finalAuthor) updateObj.author = finalAuthor;
        const upd = await updateAnnotationRemote(remoteId, updateObj);
        if(!upd.ok){
          try{ await deleteAnnotationRemote(remoteId); }catch(e){}
          const newPush = await pushAnnotationToFirestore(anns[idx]);
          if(newPush.ok){ anns[idx]._remoteId = newPush.id; saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations(); }
        }
      } else {
        const res = await pushAnnotationToFirestore(anns[idx]);
        if(res.ok){ anns[idx]._remoteId = res.id; saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations(); }
      }
    }catch(e){ console.warn('remote edit failed', e); }
  } else {
    // create new
    if(!pendingSelection) return alert('Select text first.');
    const startIdx = Math.floor(pendingSelection.start_idx);
    const endIdx = Math.floor(pendingSelection.end_idx);

    const existingExact = anns.find(a => Number(a.start_idx) === startIdx && Number(a.end_idx) === endIdx);
    if(existingExact){
      $('#annotation-editor').style.display = 'block';
      $('#annotation-editor').dataset.editing = existingExact.id;
      $('#annotation-text').value = existingExact.note || '';
      $('#selection-preview').innerText = `"${pendingSelection.text.slice(0,120)}${pendingSelection.text.length>120?'…':''}"`;
      $('#delete-annotation').style.display = 'inline-block';
      $('#delete-annotation').dataset.remoteId = existingExact._remoteId || '';
      return;
    }

    const newAnn = {
      id: String(Date.now()) + '-' + Math.floor(Math.random()*9999),
      file: window.current.filePath,
      start_idx: startIdx,
      end_idx: endIdx,
      text: pendingSelection.text,
      note: finalNote,
      author: finalAuthor || 'Stacy',
      created_at: nowISO
    };
    anns.push(newAnn); saveAnnsLocal(window.current.filePath, anns); renderArticleWithAnnotations();

    const res = await pushAnnotationToFirestore(newAnn);
    if(!res.ok){ console.warn('Firestore write failed', res.error); alert('Firestore write failed; saved locally.'); }
    else { const loc = loadAnnsLocal(window.current.filePath); const li = loc.find(a=> a.id === newAnn.id); if(li){ li._remoteId = res.id; saveAnnsLocal(window.current.filePath, loc); renderArticleWithAnnotations(); } }
  }

  $('#annotation-editor').style.display = 'none'; $('#annotation-editor').dataset.editing = ''; pendingSelection = null; window.getSelection().removeAllRanges(); hideFabAndLookup();
});

/* fetch + realtime */
async function fetchAnnotationsOnce(filePath){
  if(!filePath) return;
  try{
    const snap = await db.collection('annotations').where('file','==', normalizePath(filePath)).get();
    const anns = [];
    snap.forEach(doc => { const d = doc.data(); d._remoteId = doc.id; d.id = d.id || doc.id; anns.push(d); });
    anns.sort((a,b)=> {
      const ta = a.created_at?.toDate ? a.created_at.toDate().toISOString() : (a.created_at || a.createdAt || '');
      const tb = b.created_at?.toDate ? b.created_at.toDate().toISOString() : (b.created_at || b.createdAt || '');
      return (ta||'').localeCompare(tb||'');
    });
    saveAnnsLocal(filePath, anns);
    renderArticleWithAnnotations();
    return anns;
  }catch(e){ console.error('fetchAnnotationsOnce error', e); return null; }
}

function subscribeRealtime(filePath){
  if(unsubscribeRealtime){ try{ unsubscribeRealtime(); }catch(e){} unsubscribeRealtime = null; }
  if(pollingFallback){ clearInterval(pollingFallback); pollingFallback = null; }
  try{
    unsubscribeRealtime = db.collection('annotations').where('file','==', normalizePath(filePath)).orderBy('created_at').onSnapshot(snapshot=>{
      const anns = [];
      snapshot.forEach(doc => { const d = doc.data(); d._remoteId = doc.id; d.id = d.id || doc.id; anns.push(d); });
      anns.sort((a,b)=> {
        const ta = a.created_at?.toDate ? a.created_at.toDate().toISOString() : (a.created_at || a.createdAt || '');
        const tb = b.created_at?.toDate ? b.created_at.toDate().toISOString() : (b.created_at || b.createdAt || '');
        return (ta||'').localeCompare(tb||'');
      });
      saveAnnsLocal(filePath, anns);
      renderArticleWithAnnotations();
    }, err=>{
      console.error('onSnapshot error', err);
      if(pollingFallback) clearInterval(pollingFallback);
      pollingFallback = setInterval(()=> fetchAnnotationsOnce(filePath), 6000);
    });
  }catch(e){ console.warn('subscribeRealtime error', e); if(pollingFallback) clearInterval(pollingFallback); pollingFallback = setInterval(()=> fetchAnnotationsOnce(filePath), 6000); }
}

/* highlight click opens annotation list and scrolls */
document.addEventListener('click', (ev)=>{
  const t = ev.target;
  if(t && t.matches && t.matches('.hl')){
    const start = parseInt(t.getAttribute('data-start')), end = parseInt(t.getAttribute('data-end'));
    if(isNaN(start) || isNaN(end)) return;
    $('#right-col').classList.remove('collapsed');
    document.getElementById('right-col').scrollTop = 0;
    const anns = loadAnnsLocal(window.current.filePath) || [];
    renderAnnGroups(anns);
    setTimeout(()=>{
      const snippet = window.current.raw.slice(start, Math.min(end, start+60)).trim().slice(0,40);
      const groups = Array.from(document.querySelectorAll('#annotations-list .ann-group'));
      for(const g of groups){
        if(g.textContent && g.textContent.includes(snippet)){
          g.scrollIntoView({behavior:'smooth', block:'center'});
          g.animate([{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:500});
          break;
        }
      }
    },150);
  }
});

/* collapse buttons */
$('#collapse-left').addEventListener('click', ()=>{ $('#left-col').classList.toggle('collapsed'); });
$('#collapse-right').addEventListener('click', ()=>{ $('#right-col').classList.toggle('collapsed'); });

/* init reading loader */
async function loadReading(r){
  const url = r.download_url || `/${r.path}`;
  $('#post-title').innerText = r.title || r.path.split('/').pop();
  window.current.filePath = normalizePath(r.path);
  try{
    const res = await fetch(url, {cache:'no-store'});
    if(!res.ok) throw new Error('fetch failed');
    window.current.raw = await res.text();
    window.current.title = r.title || r.path.split('/').pop();
    await fetchAnnotationsOnce(window.current.filePath);
    renderArticleWithAnnotations();
    subscribeRealtime(window.current.filePath);
  }catch(e){
    $('#article').innerHTML = `<div class="small">Error loading ${escapeHtml(url)}</div>`;
    console.error('loadReading error', e);
  }
}

function queryParam(name){ const params = new URLSearchParams(window.location.search); return params.get(name); }

async function initApp(){
  await discoverReadings();
  const fileQuery = queryParam('file');
  if(fileQuery){
    const match = readings.find(r => normalizePath(r.path) === normalizePath(fileQuery) || r.path === fileQuery);
    if(match) { loadReading(match); return; }
    const synthetic = { path: fileQuery, title: fileQuery.split('/').pop(), download_url: `/${fileQuery}` };
    loadReading(synthetic);
    return;
  }
  if(readings.length > 0) loadReading(readings[0]);
  else { $('#article').innerHTML = '<div class="small">No readings found in /readings/. Add files or index.json.</div>'; }
}

/* Small utility: avoid native lookup/popups on double click */
document.addEventListener('dblclick', (e)=>{ /* no-op */ });

/* prevent native contextmenu/lookup from appearing on article */
$('#article').addEventListener('contextmenu', (e)=>{ e.preventDefault(); });

/* small safety: if user clicks outside selection, hide the fab/buttons */
document.addEventListener('mousedown', (e)=>{ if(e.target === annotFab || annotFab.contains(e.target) || e.target === lookupBtn || lookupBtn.contains(e.target)) return; const sel = window.getSelection(); if(!sel || sel.toString().trim()==='') hideFabAndLookup(); });

/* ---------- End of main script ---------- */
</script>
</body>
</html>
